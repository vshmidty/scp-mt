'use strict';

let _ = require('lodash');
let getCollector = require('../sql/dataCollectorGet');

let sqlStatement = require('./../sql/sqlStatement');
let dbConnect = require('./../db/connect');

let nodeUtils = require('util');
let xsODataUtils = require('../utils/utils');

let typedObjects = require('./../utils/typedObjects');
let EntityType = require('../model/entityType.js');

let typeConverter = require('./../utils/typeConverter');

let keyGenerator = require('../utils/keyGenerator');

let BadRequest = require('../utils/errors/http/badRequest');


// Types of db segments
exports.DBS_Entity = 2;
exports.DBS_ResourceNavigation = 3;
exports.DBS_Property = 4;
exports.DBS_Navigation = 6; // expanded navigation || selected navigation

exports.DbSegment = DbSegment;

/**
 * Constructs a dbSegment. A dbSegment stores all information to load data from one actual database table
 *
 * @param kind  Either Entity, Navigation in resource path, property or navigation in expand tree
 * @param entityType
 * @param nr    Id used for creating temporary table with unique names
 * @constructor
 */
function DbSegment(kind, entityType, nr) {
    this.kind = kind;
    this.previousDBSegment = null;

    this.entityType = entityType;

    // restrictions used on last segment of resource path
    this.restriction = {
        onlyCount: false, // $count used in uri
        onlyRefs: false,  // $ref used in uri
        onlyValue: false  // $value used in uri
    };

    this.isLinks = false;
    this.isCollection = undefined;
    this.singleProperty = null;

    this._end = { from: null, to: null };


    //for SQL generation
    this._DB_Schema = entityType.schema;
    this._DB_TableName = entityType.tableName;
    this._AliasName = entityType.name;
    this._AliasId = nr;
    this._Alias = this._AliasName + this._AliasId;

    /**
     * List of key predicates
     * @type {Array<{key : string,value : string}>}
     * @private
     */
    this._KeyValues = [];
    this._recordNV = [];
    /*use for post/put/delete*/
    this._recordMapFromPayload = {};

    /**
     * Input parameters if this dbSegment queries a calcview
     * @type {Array<{Key : string,Value : string}>}
     * @private
     */
    this._InputParams = [];

    /**
     * Selected property name (either by * all properties of the entity set or explicit via $select)
     * @type {Array<String>}
     */
    this._SelectedProperties = [];
    /**
     * Store column names ordered
     * @type {Array<String>}
     */
    this._SelectedPropertiesOrdered = null;
    /**
     * Store names existing of navigation properties
     * @type {Array<String>}
     */
    this._SelectedNavigations = [];      //Array of string
    /**
     * Store names of really expanded of navigation properties
     * @type {Array<String>}
     */
    this._ExpandedNavigations = [];      //Array of string
    /**
     * Store dbSegments of really expanded of navigation properties
     * @type {Map<String,DbSegment>}
     */
    this._ExpandedNavigationsDBSeg = {}; //Array of DbSegments
    /**
     * Store dbSegments of used navigation properties. May contain more navigation properties than
     * attribute _ExpandedNavigationsDBSeg
     * @type {Map<String,DbSegment>}
     */
    this._relevantNavigationSegments = {};

    this.isGenKeySelected = false;

    this.systemQueryParameter = {
        filter: null,
        orderBy: null,
        top: null,
        skip: null
    };

    this.sql = {
        stmContainer: null,
        rows: null,
        rowsInput: null,
        readPosition: 0
    };

    /**
     *
     * @type {null}
     */
    this._rowsWithGenKey = null;

    this.nextDBSegment = null;

    this.association = null;
}

/**
 * Return only the alias for the table
 * @returns {string} Alias used to reference the table
 */
DbSegment.prototype.getAlias = function () {
    return this._Alias;
};

/**
 * Return only the alias for an association
 * @returns {string} Alias used to reference the association
 */
DbSegment.prototype.getAssocAlias = function () {
    return 'Assoc' + this._AliasId;
};

/**
 * Returns the tableName with schema and alias
 * @returns {{schema: string, table: string, alias: string}}
 */
DbSegment.prototype.getAliasedTableName = function (alias) {
    return {
        schema: this._DB_Schema,
        table: this._DB_TableName,
        alias: alias || this._Alias
    };
};

/**
 * Check if the given dbSegment navigates the corresponding association from its principal end
 * @returns {boolean}
 * */
DbSegment.prototype.isPrincipal = function () {
    return this.entityType.name === this.association.principal.type;
};

/**
 * Uses properties from record and add them to the _recordMapFromPayload and _recordNV attributes.
 *
 *
 * @param context
 * @param record
 */
DbSegment.prototype.setRecordPOST = function (context, record) {
    let converterArray = typeConverter.converterFunctions.jsonPayloadToDbName;
    let value;
    let dbValue;
    let dbType;
    let i;
    let converter;

    let supportNullable = context.gModel.isNullSupported();
    let isNullable;

    const createBy = this.entityType.getAddAdmindata('create', 'by');
    const createAt = this.entityType.getAddAdmindata('create', 'at');
    const modifyBy = this.entityType.getAddAdmindata('modify', 'by');
    const modifyAt = this.entityType.getAddAdmindata('modify', 'at');

    //Loop through the properties of the entityType.
    Object.keys(this.entityType.propertiesMap).forEach(function (property) {
        //Load property from record
        value = record[property];


        if (value === undefined) {
            // Use columns default value
            dbValue = this.entityType.propertiesMap[property]['DEFAULT_VALUE'];
        } else if (value === null) {
            // Use null
            isNullable = this.entityType.propertiesMap[property]['IS_NULLABLE'] === 'TRUE';
            if (!supportNullable || !isNullable) {
                if (!((createBy && property === 'CREATED_BY') ||
                        (createAt && property === 'CREATED_AT') ||
                        (modifyBy && property === 'MODIFIED_BY') ||
                        (modifyAt && property === 'MODIFIED_AT'))
                ) {
                    throw new BadRequest('The serialized resource has an missing value for member ' + property);
                }
            }
            dbValue = null;
        } else {
            //Use the converted value
            dbType = this.entityType.propertiesMap[property]['DATA_TYPE_NAME'];
            converter = converterArray[typeConverter.dbTypeNameToODataTypeName[dbType]];

            dbValue = converter(value, dbType);
        }


        this._recordMapFromPayload[property] = dbValue;
        this._recordNV.push({ name: property, value: dbValue });
    }.bind(this));

    //set KeyValues
    let max = this.entityType.keys.names.length;
    for (i = 0; i < max; i++) {
        this._KeyValues.push(
            {
                name: this.entityType.keys.names[i],
                value: this._recordMapFromPayload[this.entityType.keys.names[i]]
            }
        );
    }

    //Check that no additional properties (and also no inline content) are send to server
    /*Object.keys(record).forEach(function (property) {
        if (!this.entityType.propertiesMap[property]) {
            if (!this.entityType.navPropertiesMap[property]) {
                throw new BadRequest('Property "' + property + '" unknown.');
            } else {
                throw new NotSupported('POST with inlined content "' + property + '" not supported.');
            }

        }
    }.bind(this));*/
};


DbSegment.prototype.getKey = function (key) {
    for (let i = 0; i < this._KeyValues.length; i++) {
        if (this._KeyValues[i].name === key) {
            return this._KeyValues[i];
        }
    }
    return undefined;
};

DbSegment.prototype.hasKeyValues = function () {
    return this._KeyValues.length > 0;
};


DbSegment.prototype.setRecordPUT = function (context, record) {
    let supportNullable = context.gModel.isNullSupported();
    let isNullable;
    let converterArray = typeConverter.converterFunctions.jsonPayloadToDbName;
    let value;
    let dbValue;
    let dbType;

    const createBy = this.entityType.getAddAdmindata('create', 'by');
    const createAt = this.entityType.getAddAdmindata('create', 'at');
    const modifyBy = this.entityType.getAddAdmindata('modify', 'by');
    const modifyAt = this.entityType.getAddAdmindata('modify', 'at');


    //Check if all required properties are send to server
    Object.keys(this.entityType.propertiesMap).forEach(function (property) {
        let kv = this.getKey(property);
        if (kv) {
            dbValue = kv.value;
            this._recordMapFromPayload[property] = dbValue;
            this._recordNV.push({ name: property, value: dbValue });
        } else {
            value = record[property];
            dbValue = null;
            dbType = this.entityType.propertiesMap[property]['DATA_TYPE_NAME'];
            isNullable = this.entityType.propertiesMap[property]['IS_NULLABLE'] === 'TRUE';
            if (value === undefined) {
                if (supportNullable && isNullable) {
                    dbValue = null;
                } else {
                    if (!((createBy && property === 'CREATED_BY') ||
                            (createAt && property === 'CREATED_AT') ||
                            (modifyBy && property === 'MODIFIED_BY') ||
                            (modifyAt && property === 'MODIFIED_AT'))
                    ) {
                        throw new BadRequest('The serialized resource has an missing value for member ' + property);
                    }
                }
            } else {
                dbValue = converterArray[typeConverter.dbTypeNameToODataTypeName[dbType]](value, dbType);
            }

            this._recordMapFromPayload[property] = dbValue;
            this._recordNV.push({ name: property, value: dbValue });
        }
    }.bind(this));

    //Check that no additional properties (and also no inline content) are send to server
    /*Object.keys(record).forEach(function (property) {
        if (!this.entityType.propertiesMap[property]) {
            if (!this.entityType.navPropertiesMap[property]) {
                throw new BadRequest('Property "' + property + '" unknown.');
            } else {
                throw new NotSupported('PUT with inlined content "' + property + '" not supported.');
            }
        }
    }.bind(this));*/
};

DbSegment.setRecordPutPostLinks = function (context) {
    let toBeUpdated = context.oData.links.toBeUpdated;
    let keySource = context.oData.links.keySource;

    // Add keys
    toBeUpdated._KeyValues.forEach(function (key) {
        toBeUpdated._recordMapFromPayload[key.name] = key.value;
        toBeUpdated._recordNV.push({ name: key.name, value: key.value });
    });

    // Add foreign keys, e.g. Employees.ManagerId
    let fkeys = toBeUpdated.getQForeignKeyProperties();
    fkeys.forEach(function (key, i) {
        toBeUpdated._recordMapFromPayload[key.property] = keySource._KeyValues[i].value;
        toBeUpdated._recordNV.push({ name: key.property, value: keySource._KeyValues[i].value });
    });
};

DbSegment.setRecordDeleteLinks = function (context) {
    let toBeUpdated = context.oData.links.toBeUpdated;

    // Add keys
    toBeUpdated._KeyValues.forEach(function (key) {
        toBeUpdated._recordMapFromPayload[key.name] = key.value;
        toBeUpdated._recordNV.push({ name: key.name, value: key.value });
    });
    // Skip adding foreign keys, so that later in movePayloadFromSegmentToSelectStm they are set to 'null'
};

/**
 * Returns the tableName with schema and alias
 * @returns {{schema: string, table: string}}
 */
DbSegment.prototype.getQTableNameNoAlias = function () {
    return {
        schema: this._DB_Schema,
        table: this._DB_TableName
    };
};
/**
 * @returns {{type: string, joinProperties: [string], multiplicity: string}|null}
 */
DbSegment.prototype.getTo = function () {
    return this._end.to;
};

/**
 * @param {{type: string, joinProperties: [string], multiplicity: string}} endTo
 */
DbSegment.prototype.setTo = function (endTo) {
    this._end.to = endTo;
};


/**
 * @param {{type: string, joinpProperties: [string], multiplicity: string}} endFrom
 */
DbSegment.prototype.setFrom = function (endFrom) {
    this._end.from = endFrom;
};
/**
 * @returns {{type: string, joinProperties: [string], multiplicity: string}}
 */
DbSegment.prototype.getFrom = function () {
    return this._end.from;
};

DbSegment.prototype.setOver = function (endOver) {
    this._end.over = endOver;
};

DbSegment.prototype.getOver = function () {
    return this._end.over;
};

DbSegment.prototype.setLinks = function () {
    if (this.previousDBSegment) {
        this.previousDBSegment.setLinks();
    } else {
        this.isLinks = true;
    }
};

/**
 * Returns the key names as TableColumn array for usage in the INSERT, UPDATE or CREATE TABLE SQL statements.
 * @returns {sql.TableColumn[]}
 */
DbSegment.prototype.getQKeyProperties = function () {
    let ret = [];

    for (let i = 0; i < this.entityType.keys.names.length; i++) {
        ret.push(new sqlStatement.TableColumn(this._Alias, this.entityType.keys.names[i]));
    }
    return ret;
};

/**
 * Returns the key names as SelectProperty array for usage in a SELECT SQL statement.
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getQKeyPropertiesForSelect = function () {
    return this._createSelectProperties(this._Alias, this.entityType.keys.names);
};

/**
 * Creates an array of SelectProperty instances for usage in a SELECT SQL statement.
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype._createSelectProperties = function (tableAlias, propertyNames, with0123Alias) {
    let propertiesMap = this.entityType.propertiesMap;

    return propertyNames.map(function (propertyName, index) {
        let property = propertiesMap[propertyName];
        let propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;

        return new sqlStatement.SelectProperty(tableAlias, propertyName, propertyType,
            with0123Alias ? index.toString() : undefined);
    });
};

DbSegment.prototype.getQKeyPropertiesWith0123AliasForSelect = function (noTable) {
    return this._createSelectProperties(noTable ? null : this._Alias, this.entityType.keys.names, true);
};

DbSegment.prototype.getKeyProperties0123ForSelect = function (noTable) {
    let ret = [];


    let keyNames = this.entityType.keyNamesOrdered;

    for (let i = 0; i < keyNames.length; i++) {
        ret.push(
            new sqlStatement.SelectProperty(noTable ? null : this._Alias, i.toString(), null)
        );
    }
    return ret;
};

DbSegment.prototype.prepareInputParameters = function (context) {
    context.logger.silly('dbsegment', 'prepareInputParameters');

    let etInParams = [];
    this.entityType.properties.forEach(function (property) {
        if (property.KIND === EntityType.entityKind.inputParameters) {
            etInParams.push(property);
        }
    });
    etInParams.forEach(function (etInParam) {
        let param = _.find(this._KeyValues, function (kv) {
            return kv.name === etInParam.COLUMN_NAME;
        });
        if (param) {
            context.logger.silly('dbsegment', 'name: ' + param.name + '(' + typeConverter.dbTypeNameToODataTypeName[etInParam.DATA_TYPE_NAME] + ')');

            this._InputParams.push({ key: param.name, value: param.value });
        }
    }, this);
};

/**
 * Adds a table input parameter when accessing a calcview with localVariables.
 * E.g. OrderValues.hdbcalculationview with IP_LANG and IP_CLIENT
 * Call via: http://.../material.xsodata/OrderValueParameters(IP_CLIENT='100',IP_LANG='E')/Results?$format=json
 *
 * @param context
 * @param key
 * @param value
 */
DbSegment.prototype.addInputParameter = function (context, key, value) {
    context.logger.silly('dbsegment', 'addInputParameter');
    context.logger.silly('dbsegment', 'name: ' + key + '(' + typeConverter.dbTypeNameToODataTypeName[this.entityType.inputParameters[key].COLUMN_TYPE_D] + ')');
    this._InputParams.push({ key: key, value: value });
};

DbSegment.prototype.getInputParameters = function () {
    return this._InputParams;
};

DbSegment.prototype.getParameterValue = function (parameterName) {
    let param = _.find(this._InputParams, function (kv) {
        return kv.key === parameterName;
    });
    if (param) {
        return param.value;
    }
    /*
     if(!param){
     param = _.find(this._KeyValues, function(kv){return kv.name===parameterName});
     return param.value.string;
     }else{
     return param.value;
     }*/
};

DbSegment.prototype.getKeyProperties0123ForSelectAs0123 = function (noTable) {
    let ret = [];
    let keyNames;
    let keyName;
    let property;
    let selectProperty;
    let propertyType;
    let paramValue;
    let i;

    keyNames = this.entityType.keyNamesOrdered;

    for (i = 0; i < keyNames.length; i++) {
        keyName = keyNames[i];
        property = this.entityType.propertiesMap[keyName];
        selectProperty = null;

        if (property.KIND === EntityType.entityKind.inputParameters) {
            paramValue = this.getParameterValue(property.COLUMN_NAME);
            selectProperty = new sqlStatement.ParameterSelectProperty(noTable ? null : this._Alias, keyName, i.toString(), paramValue);
        } else {
            propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;
            selectProperty = new sqlStatement.SelectProperty(noTable ? null : this._Alias, keyName, propertyType, i.toString());
        }

        ret.push(selectProperty);
    }
    return ret;
};

/**
 * Returns a selectProperty for usage in the select part of sql statements
 * The property are named "0","1","2",... and have as type the type of the corresponding key ( ordered by position
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getKeyProperties0123ForCreate = function () {
    let ret = [];


    let keyNames = this.entityType.keyNamesOrdered;
    let propertiesMap = this.entityType.propertiesMap;

    for (let i = 0; i < keyNames.length; i++) {
        let keyName = keyNames[i];
        let property = propertiesMap[keyName];
        let typeString = property.DATA_TYPE_NAME;

        if (typeString === 'DECIMAL') {
            typeString += '(' + property.LENGTH.toString() + ',' + property.SCALE.toString() + ')';
        } else if (typeString === 'VARCHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'NVARCHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'ALPHANUM') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'CHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'NCHAR') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'VARBINARY') {
            typeString += '(' + property.LENGTH.toString() + ')';
        } else if (typeString === 'SHORTTEXT') {
            typeString = 'NVARCHAR(10)';
        }

        ret.push(
            new sqlStatement.CreateProperty(i.toString(), typeString)
        );
    }
    return ret;
};

DbSegment.prototype.getKeyProperties0123ForOrderBy = function (noTable) {
    let ret = [];

    let keyNames = this.entityType.keyNamesOrdered;

    for (let i = 0; i < keyNames.length; i++) {
        ret.push(
            new typedObjects.SortOrder(new typedObjects.Property(i.toString(), noTable ? null : this._Alias), 'ASC')
        );
    }
    return ret;
};

DbSegment.prototype.getKeyPropertiesNotSelectedForSelect = function (noTable) {
    let ret = [];
    let keyNames;
    let i;
    let keyName;
    let key;
    let propertyType;

    keyNames = this.entityType.keyNamesOrdered;

    for (i = 0; i < keyNames.length; i++) {
        keyName = keyNames[i];
        key = this.entityType.propertiesMap[keyName];

        if ((this._getSortedSelectProperties().indexOf(keyName) === -1) &&
            (this._SelectedNavigations.indexOf(keyName) === -1)) {
            propertyType = key.aggregate ? null : key.DATA_TYPE_NAME;
            ret.push(new sqlStatement.SelectProperty(noTable ? null : this._Alias, keyName, propertyType, null));
        }
    }
    return ret;
};

DbSegment.prototype.getKeyPropertiesNotSelectedForCreate = function () {
    let ret = [];

    let keyNames = this.entityType.keyNamesOrdered;
    let propertiesMap = this.entityType.propertiesMap;


    for (let i = 0; i < keyNames.length; i++) {
        let keyName = keyNames[i];
        if ((this._getSortedSelectProperties().indexOf(keyName) === -1) && (this._SelectedNavigations.indexOf(keyName) === -1)) {
            let property = propertiesMap[keyName];
            let typeString = createPropertyTypeString(property);

            ret.push(
                new sqlStatement.CreateProperty(keyName, typeString)
            );
        }
    }
    return ret;
};

DbSegment.prototype.getPropertiesForCreate = function () {
    let ret = [];

    //let properties = this.entityType.properties;
    let properties = this._getSortedSelectProperties();
    for (let i = 0; i < properties.length; i++) {
        let property = this.entityType.propertiesMap[properties[i]];

        ret.push(
            createSqlCreateProperty(property)
        );
    }
    return ret;
};

// Get the properties (as full objects, e.g. with data type etc.) of the associative entity (3rd table)
// via the association's 'over', for CREATE statements
DbSegment.prototype.getOverPropertiesForCreate = function () {
    let ret = [];
    let over = this.getOver();
    let properties = [];
    // fetch Key property from original table

    const from = this.getFrom();
    for (let i = 0; i < from.joinproperties.length; i++) {
        const keyPropOrig = this.previousDBSegment.entityType.propertiesMap[from.joinproperties[i]];
        const keyProp = xsODataUtils.clone(keyPropOrig);
        keyProp.COLUMN_NAME = from.overRefProp[i];// update the column and table name according to the associative table
        keyProp.TABLE_NAME = over.object;
        properties.push(keyProp);
    }

    const to = this.getTo();

    for (let i = 0; i < to.joinproperties.length; i++) {
        const keyPropOrig = this.entityType.propertiesMap[to.joinproperties[i]];
        const keyProp = xsODataUtils.clone(keyPropOrig);
        keyProp.COLUMN_NAME = to.overRefProp[i];
        keyProp.TABLE_NAME = over.object;
        properties.push(keyProp);
    }

    for (let i = 0; i < properties.length; i++) {
        ret.push(
            createSqlCreateProperty(properties[i])
        );
    }
    return ret;
};

function createSqlCreateProperty(property) {
    return new sqlStatement.CreateProperty(property.COLUMN_NAME, createPropertyTypeString(property));
}

function createPropertyTypeString(property) {
    let typeString = property.DATA_TYPE_NAME;

    if (typeString === 'DECIMAL') {
        typeString += '(' + property.LENGTH.toString() + ',' + property.SCALE.toString() + ')';
    } else if (typeString === 'VARCHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'NVARCHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'ALPHANUM') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'CHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'NCHAR') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'VARBINARY') {
        typeString += '(' + property.LENGTH.toString() + ')';
    } else if (typeString === 'SHORTTEXT') {
        typeString = 'NVARCHAR(10)';
    }

    return typeString;
}


DbSegment.prototype.getPropertiesForSelect = function (noTable) {
    let ret = [],
        properties = this._getSortedSelectProperties(),
        property,
        selectProperty,
        propertyType;

    for (let i = 0; i < properties.length; i++) {
        property = this.entityType.propertiesMap[properties[i]];
        selectProperty = null;

        if (property.KIND === EntityType.entityKind.inputParameters) {
            let paramValue = this.getParameterValue(property.COLUMN_NAME);
            selectProperty = new sqlStatement.ParameterSelectProperty(noTable ? null : this._Alias, properties[i], null, paramValue);
        } else {
            propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;
            selectProperty = new sqlStatement.SelectProperty(noTable ? null : this._Alias, properties[i], propertyType, null);
        }

        ret.push(selectProperty);
    }
    return ret;
};

// Get the properties (as names only) of the associative entity (3rd table) via the association's 'over', for SELECT statements
DbSegment.prototype.getOverPropertiesForSelect = function (rId) {
    let ret = [], selectProperty;
    let over = this.getOver();
    let properties = [];

    for (let i = 0; i < over.principal.length; i++) {
        properties.push(over.principal[i]);
    }

    for (let i = 0; i < over.dependent.length; i++) {
        properties.push(over.dependent[i]);
    }

    for (let i = 0; i < properties.length; i++) {
        selectProperty = new sqlStatement.SelectProperty(rId, properties[i], null);
        ret.push(
            selectProperty
        );
    }
    return ret;
};

DbSegment.prototype.getAllSelectedPropertiesConsideringAggregates = function (noTable) {
    let table = noTable ? null : this._Alias;
    let withAlias = true;
    return this._getSortedSelectProperties().map(createSelectProperty.bind(this, table, withAlias));
};

DbSegment.prototype.getPropertyAsSelectProperty = function (propertyName) {
    let withAlias = false;
    return createSelectProperty.call(this, this._Alias, withAlias, propertyName);
};

function createSelectProperty(table, withAlias, propertyName) {
    /* jshint -W040 */
    let aggregate;
    let alias;
    let property;
    let propertyType;

    aggregate = this.entityType.getAggregates().filter(function (aggregate) {
        return propertyName === aggregate.column;
    }).shift();


    if (aggregate) {
        alias = withAlias && propertyName;
        return new sqlStatement.AggregateSelectProperty(aggregate.function.toLowerCase(), table, propertyName, alias);
    }

    property = this.entityType.propertiesMap[propertyName];
    if (property.KIND === EntityType.entityKind.inputParameters) {
        return new sqlStatement.ParameterSelectProperty(table, propertyName, null, this.getKey(propertyName));
    }

    propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;
    return new sqlStatement.SelectProperty(table, propertyName, propertyType, null);
    /* jshint +W040 */
}

DbSegment.prototype.getNonKeyJoinProperties = function () {
    let keys = this.entityType.keyNamesOrdered;
    let joinProperties = this.getTo() && this.getTo().joinproperties || [];
    let joinProps = joinProperties.filter(function (joinProp) {
        return keys.indexOf(joinProp) < 0;
    });

    return concatJoinProperties([], joinProps, this._Alias);
};

DbSegment.prototype.getAllSelectedIncludingJoinPropertiesConsideringAggregates = function (noTable) {
    let table = noTable ? null : this._Alias;
    let selectedProperties = this.getAllSelectedPropertiesConsideringAggregates(noTable);
    let joinProps = [];
    if (this.getTo()) {
        joinProps = this.getTo().joinproperties;
    } else {
        let relevantNavigationSegments = this.getRelevantNavigationSegments();
        joinProps = getJoinProperties(relevantNavigationSegments, this._SelectedNavigations);
    }

    return concatJoinProperties(selectedProperties, joinProps, table);
};

function getJoinProperties(relevantNavigationSegments, selectedNavigations) {
    return selectedNavigations.reduce(toJoinProperties, []);

    function toJoinProperties(joinProps, selectedNavigation) {
        let selectedNavigationSegment = relevantNavigationSegments[selectedNavigation];
        if (selectedNavigationSegment) {
            let from = selectedNavigationSegment.getFrom();
            if (from) {
                return joinProps.concat(from.joinproperties);
            }
        }
        return joinProps;
    }
}

DbSegment.prototype.getAllSelectedNonAggregatePropertiesForOrderBy = function (noTable) {
    let table = noTable ? null : this._Alias;
    let entityType = this.entityType;
    let selectedProperties = this._getSortedSelectProperties();


    if (entityType.hasAggregates()) {
        selectedProperties = selectedProperties.filter(aggregates);
    }

    return selectedProperties.map(toSqlSelectProperty);

    function aggregates(selectedProp) {
        return !entityType.getAggregates().some(withColumnName);

        function withColumnName(aggregate) {
            return aggregate.column === selectedProp;
        }
    }

    function toSqlSelectProperty(selectedProperty) {
        return new sqlStatement.SelectProperty(table, selectedProperty);
    }
};

DbSegment.prototype.getAllSelectedNonAggregateIncludingJoinPropertiesForGroupBy = function (noTable) {
    let table = noTable ? null : this._Alias;
    let selectedProps = this.getAllSelectedNonAggregatePropertiesForOrderBy(noTable, true);
    let joinProps = [];
    if (this.getTo()) {
        joinProps = this.getTo().joinproperties;
    } else {
        let relevantNavigationSegments = this.getRelevantNavigationSegments();
        joinProps = getJoinProperties(relevantNavigationSegments, this._SelectedNavigations);
    }

    return concatJoinProperties(selectedProps, joinProps, table);
};

function concatJoinProperties(selectedProps, joinProps, table) {
    joinProps.forEach(function (joinProp) {
        let shouldAdd = !selectedProps.some(function (selectProp) {
            return selectProp.property === joinProp;
        });

        if (shouldAdd) {
            selectedProps.push(new sqlStatement.SelectProperty(table, joinProp, null));
        }
    });

    return selectedProps;
}

DbSegment.prototype.getNavPropertiesForCreate = function () {
    let ret = [];

    //let properties = this.entityType.properties;
    let properties = this._SelectedNavigations;
    for (let i = 0; i < properties.length; i++) {
        let navPropertyName = properties[i];

        let navDbSeg = this._relevantNavigationSegments[navPropertyName];
        if (!navDbSeg) {
            continue;
        }
        let propertyNames = navDbSeg.getFrom().joinproperties;

        for (let ii = 0; ii < propertyNames.length; ii++) {
            let property = this.entityType.propertiesMap[propertyNames[ii]];
            let propertyName = property.COLUMN_NAME;
            if (this._getSortedSelectProperties().indexOf(propertyName) > -1) {
                continue;
            }
            let typeString = property.DATA_TYPE_NAME;

            if (typeString === 'DECIMAL') {
                typeString += '(' + property.LENGTH.toString() + ',' + property.SCALE.toString() + ')';
            } else if (typeString === 'VARCHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'NVARCHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'ALPHANUM') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'CHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'NCHAR') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'VARBINARY') {
                typeString += '(' + property.LENGTH.toString() + ')';
            } else if (typeString === 'SHORTTEXT') {
                typeString = 'NVARCHAR(10)';
            }
            ret.push(
                new sqlStatement.CreateProperty(propertyName, typeString)
            );
        }
    }
    return ret;
};
DbSegment.prototype.getNavPropertiesForSelect = function (noTable) {
    let ret = [];

    //let properties = this.entityType.properties;
    let properties = this._SelectedNavigations;
    for (let i = 0; i < properties.length; i++) {
        let navPropertyName = properties[i];
        if (this._getSortedSelectProperties().indexOf(navPropertyName) > -1) {
            continue;
        }
        let navDbSeg = this._relevantNavigationSegments[navPropertyName];
        if (!navDbSeg) {
            continue;
        }
        let propertyNames = navDbSeg.getFrom().joinproperties;


        for (let ii = 0; ii < propertyNames.length; ii++) {
            let property = this.entityType.propertiesMap[propertyNames[ii]];
            let propertyName = property.COLUMN_NAME;
            if (this._getSortedSelectProperties().indexOf(propertyName) > -1) {
                continue;
            }

            ret.push(
                new sqlStatement.SelectProperty(noTable ? null : this._Alias, propertyNames[ii], null)
            );
        }
    }
    return ret;
};


/**
 * Returns the key names of used/expanded navigation selectProperty list (containing table alias and key name)
 * For usage in the select part of sql statements
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getNonKeyNonSelectedProperties4Expansion = function () {
    //
    let ret = [];
    for (let i = 0; i < this._ExpandedNavigations.length; i++) {
        let exp = this._relevantNavigationSegments[this._ExpandedNavigations[i]];
        let from = exp._end.from;

        for (let ii = 0; ii < from.joinproperties.length; ii++) {
            let joinProperty = from.joinproperties[ii];

            //Non Key
            if (this.entityType.keys.names.indexOf(joinProperty) === -1) {
                if (this._getSortedSelectProperties().indexOf(joinProperty) === -1) {

                    ret.push(
                        new sqlStatement.SelectProperty(this._Alias, joinProperty, null)
                    );
                }
            }
        }
    }
    return ret;
};


/**
 * Returns non key properties as array for usage in the INSERT, UPDATE or CREATE TABLE SQL statements.
 * @returns {sqlStatement.TableColumn[]}
 */
DbSegment.prototype.getQNonKeyProperties = function () {

    let ret = [];
    let propertyName;


    for (let i = 0; i < this._getSortedSelectProperties().length; i++) {
        propertyName = this._getSortedSelectProperties()[i];

        if (this.entityType.keys.names.indexOf(propertyName) === -1) {
            ret.push(new sqlStatement.TableColumn(this._Alias, propertyName));
        }
    }


    return ret;
};

/**
 * Returns non key properties as array for usage in a SELECT SQL statement.
 * @returns {sqlStatement.SelectProperty[]}
 */
DbSegment.prototype.getQNonKeyPropertiesForSelect = function () {
    let ret = [];
    let propertiesMap = this.entityType.propertiesMap;
    let propertyName;
    let property;
    let propertyType;

    for (let i = 0; i < this._getSortedSelectProperties().length; i++) {
        propertyName = this._getSortedSelectProperties()[i];

        if (this.entityType.keys.names.indexOf(propertyName) === -1) {
            property = propertiesMap[propertyName];
            propertyType = property.aggregate ? null : property.DATA_TYPE_NAME;

            ret.push(new sqlStatement.SelectProperty(this._Alias, propertyName, propertyType, null));
        }
    }
    return ret;
};

/**
 * for this DBSeg, returns the foreign key for prev/next DBSeg
 * */
DbSegment.prototype.getQForeignKeyProperties = function () {
    let ret = [];
    let fKeys;
    if (this.previousDBSegment) {
        fKeys = this.getTo().joinproperties;
    } else if (this.nextDBSegment) {
        let refDBSeg = this.nextDBSegment;
        fKeys = refDBSeg.getFrom().joinproperties;
    } else {
        // error
    }

    let alias = this._Alias;
    fKeys.forEach(function (fkeyName) {
        ret.push(
            new sqlStatement.SelectProperty(alias, fkeyName, null)
        );
    });

    return ret;
};

/**
 * Returns the key names and values
 * For usage in where clauses
 * @returns {{key : sqlStatement.Property, value : string}[]}
 */
DbSegment.prototype.getQKeyWithValues = function (alias) {
    let ret = [];
    for (let i = 0; i < this._KeyValues.length; i++) {
        let etProperty = this.entityType.propertiesMap[this._KeyValues[i].name];
        if (etProperty.KIND !== EntityType.entityKind.inputParameters) {
            ret.push({
                key: new typedObjects.Property(this._KeyValues[i].name, alias ? alias : this._Alias),
                value: this._KeyValues[i].value
            });
        }
    }
    return ret;
};

DbSegment.prototype.getQKeyWithValuesDB = function (alias) {
    let ret = [];

    for (let i = 0; i < this._KeyValues.length; i++) {

        ret.push({
            key: new typedObjects.Property(this._KeyValues[i].name, alias ? alias : this._Alias),
            value: new typedObjects.DbValue(this._KeyValues[i].value)
        });
    }
    return ret;
};

DbSegment.prototype.getQForeignKeyWithValues = function (alias) {
    let ret = [], refDBSeg, fkeys;
    if (this.previousDBSegment) {
        refDBSeg = this.previousDBSegment;
        fkeys = this.getTo().joinproperties;
    } else if (this.nextDBSegment) {
        refDBSeg = this.nextDBSegment;
        fkeys = refDBSeg.getFrom().joinproperties;
    } else {
        // error
    }

    let a = (alias ? alias : this._Alias);
    fkeys.forEach(function (fkeyName, i) {
        ret.push({
            key: new typedObjects.Property(fkeyName, a),
            value: refDBSeg._KeyValues[i].value
        });
    });

    return ret;
};

DbSegment.prototype.getOverPropertiesWithValues = function () {
    let ret = [], dbSeg, refDBSeg;
    //var a = (alias ? alias : this._Alias);

    if (this.previousDBSegment) {
        refDBSeg = this.previousDBSegment;
        dbSeg = this;
    } else if (this.nextDBSegment) {
        refDBSeg = this.nextDBSegment;
        dbSeg = this;
    }

    let over = this.getOver();

    let keyProp1 = over.principal;
    keyProp1.forEach(function (fkeyName, i) {
        ret.push({
            key: new typedObjects.Property(fkeyName),
            value: refDBSeg._KeyValues[i].value
        });
    });

    let keyProp2 = over.dependent;
    keyProp2.forEach(function (fKeyName, i) {
        ret.push({
            key: new typedObjects.Property(fKeyName),
            value: dbSeg._KeyValues[i].value
        });
    });

    return ret;
};

/*
DbSegment.prototype.dump = function (logger, addText) {
    let text = addText || 'DbSegment: ';
    let filter = function (key, value) {
        if (key === '__metadata' || key === 'previousDBSegment') {
            return undefined;
        }
        return value;
    };
    logger.debug(text + JSON.stringify(this, filter, 4));
};
*/

/**
 * Add a  navigationDbSegment to the expand tree
 *
 * @param navPropName Name of the expanded navigation property
 * @param navigationDbSegment Corresponding dbSegment
 */
DbSegment.prototype.addExpandDbSegment = function (navPropName, navigationDbSegment) {
    if (this.entityType.navPropertiesMap[navPropName]) {
        navigationDbSegment.isExpand = true;
        this._ExpandedNavigations.push(navPropName);
        this._ExpandedNavigationsDBSeg[navPropName] = navigationDbSegment;
        this._relevantNavigationSegments[navPropName] = navigationDbSegment;
    }
};

DbSegment.prototype.addRelevantNavigationSegment = function (navPropName, dbSeg) {
    if (this.entityType.navPropertiesMap[navPropName]) {
        this._relevantNavigationSegments[navPropName] = dbSeg;
    }
};

DbSegment.prototype.getRelevantNavigationSegments = function () {
    return this._relevantNavigationSegments;
};

/**
 * Adds all properties and navigation propertiy of the dbSegments entityset to the lists:
 * _SelecdtedProperties and _SelectedNavigations
 */
DbSegment.prototype.addAllProperties = function () {
    let i;

    let properties = this.entityType.properties;
    for (i = 0; i < properties.length; i++) {
        this._SelectedProperties.push(properties[i].COLUMN_NAME);
        this._SelectedPropertiesOrdered = null;
    }

    /*add all navigations  in the OData 2.0 Spec (file://dwdf207/PTU_IW/50_Development/Web%202.0%20Communication%20Team/61_OData_Specification_V2.0/%5Bms-odata%5DV2.pdf)
     is written
     If a star appears in a selectItem following a selectedNavProperty, all non-navigation properties of
     the entity or entities represented by the prior selectedNavProperty MUST be included in the
     response.
     However, since ABAP, XS1 and MS add also the navigation properties on star we do the same here too
     */

    properties = this.entityType.navPropertyNames;
    for (i = 0; i < properties.length; i++) {
        let nav = properties[i];
        if (this._SelectedNavigations.indexOf(nav) === -1) {
            this._SelectedNavigations.push(nav);
        }

    }

    this.isGenKeySelected = true;
};

DbSegment.prototype._getSortedSelectProperties = function () {

    if (!this._SelectedPropertiesOrdered) {
        this._SelectedPropertiesOrdered = _.intersection(this.entityType.propertyNames, this._SelectedProperties);
    }

    return this._SelectedPropertiesOrdered;
};

/**
 * Add a property to list _SelectedProperties
 * @param propertyName
 */
DbSegment.prototype.addSelectProperties = function (propertyName) {

    if (this.entityType.keys.generatedKey === propertyName) {
        this.isGenKeySelected = true;
        return;
    }

    //check if property is per service definition included
    if (this.entityType.properties.with) {
        if (this.entityType.properties.with.indexOf(propertyName) > -1) {
            this._SelectedProperties.push(propertyName);
            this._SelectedPropertiesOrdered = null;
            return;
        }
    }

    if (this.entityType.properties.without) {
        if (this.entityType.properties.without.indexOf(propertyName) > -1) {
            throw new Error('Error in $select system query option: selected property is not expanded or does not exist.');
        }
    }

    //check if property is available
    if (this.entityType.propertiesMap[propertyName]) {
        this._SelectedProperties.push(propertyName);
        this._SelectedPropertiesOrdered = null;
        return;
    }

    //check for navigation property
    if (this.entityType.navPropertiesMap[propertyName]) {
        if (this._SelectedNavigations.indexOf(propertyName) === -1) {
            this._SelectedNavigations.push(propertyName);
            return;
        }
    }

    throw(new BadRequest('property "' + propertyName + '" does not exist'));
};

DbSegment.prototype.isNavigationProperty = function (propertyName) {
    return !!this.entityType.navPropertiesMap[propertyName];
};

DbSegment.prototype.getSelectedPropsWithGenKey = function getSelectedPropsWithGenKey() {
    if (this.isGenKeySelected && this.entityType.keys.generatedKey) {
        return [this.entityType.keys.generatedKey].concat(this._getSortedSelectProperties());
    }

    return this._getSortedSelectProperties();
};

/**
 * If a generic key is defined this method clones the rows selected by this dbSegment and adds a generated key.
 * The Cloned rows are returned.
 * @returns {Array}
 */
DbSegment.prototype.getRowsWithGenKey = function getRowsWithGenKey() {
    let genKey = this.entityType.keys.generatedKey;

    if (genKey) {
        if (!this._rowsWithGenKey) {
            this._rowsWithGenKey = this.sql.rows.map(function (row, index) {
                // let cloneRow = xsODataUtils.clone(row);
                let cloneRow = {};
                for (let key of Object.keys(row)) {
                    cloneRow[key] = row[key];
                }

                let genKeyValue = keyGenerator.createGenKeyValue(index);
                cloneRow[genKey] = genKeyValue;
                cloneRow['0'] = genKeyValue;

                return cloneRow;
            });
        }

        return this._rowsWithGenKey;
    }

    return this.sql.rows;
};

DbSegment.prototype.getKeysProperties = function getKeysProperties() {
    let genKey = this.entityType.keys.generatedKey;

    if (genKey) {
        return [keyGenerator.createGenKeyProperty(genKey)];
    }

    return this.entityType.keys.names.map(function toKeysProperties(keyName) {
        return this.entityType.propertiesMap[keyName];
    }.bind(this));

};

/**
 * @param {{name : string, value: string}[]} keyValuePairs
 */
DbSegment.prototype.setKeyValues = function (keyValuePairs) {
    let i;
    let kNV;
    let keyHelperMap = {}; //stores keys with name for easy comparision

    if (nodeUtils.isArray(keyValuePairs)) {
        this._KeyValues = keyValuePairs;

        for (i = 0; i < keyValuePairs.length; i++) {
            kNV = keyValuePairs[i];
            keyHelperMap[kNV.name] = kNV.value;
        }
    } else {
        this._KeyValues = [
            {
                name: this.entityType.keys.names[0],
                value: keyValuePairs
            }
        ];
        keyHelperMap[this.entityType.keys.names[0]] = keyValuePairs;
    }


    //Check if all keys are provided
    let key;
    for (i = 0; i < this.entityType.keys.names.length; i++) {
        key = this.entityType.keys.names[i];
        if (!keyHelperMap[key]) {
            throw new BadRequest('Insufficient key values');
        }
    }

};

DbSegment.prototype.getETag = function getETag(context, callback) {
    let eTagSelectStmt = sqlStatement.createSelectStmtForETag(this);

    dbConnect.connect(context, function (err, context) {
        if (err) {
            return callback(err);
        }

        return getCollector.executeSelect(context, eTagSelectStmt, function (error, dbRows) {
            let eTag,
                entity;

            if (error) {
                return callback(error);
            }

            entity = dbRows[0];
            eTag = entity ? entity["__etag"] : undefined;

            return callback(null, eTag);
        });
    });
};
