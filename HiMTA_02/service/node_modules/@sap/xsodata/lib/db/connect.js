'use strict';
/**
 * Add  <db> attribute to <context>
 * Uses <context>.<handlerConfiguration.dbConfiguration>
 * <db> = {
 *     client : hdb-client
 * }
 */

const hdb = require('hdb');
const async = require('async');
const utils = require('./../utils/utils');
const Measurement = require('./../utils/measurement');

const RwLock = require('rwlock');
const locks = new RwLock();

const InternalError = require('./../utils/errors/internalError');
const ApplicationError = require('./../utils/errors/applicationError');
const dbVersionChecks = require('./dbVersionChecks');
const tableCleanup = require('./../utils/tableCleanup');

const SqlError = require('../utils/errors/sqlError');

/**
 * Executes an sql command on the current db connection
 *
 * @param sql
 * @param context
 * @param asyncDone
 */
function execSQL(sql, context, asyncDone) {
    context.logger.silly('db', 'exec sql ' + sql);
    context.db.client.exec(sql, function (err) {
        if (err) {
            return asyncDone(new SqlError(context, err), context);
        }

        return asyncDone(null, context);
    });
}

function loadDbVersion(context, asyncDone) {

    if (!context.gModel) {
        return asyncDone(null, context);
    }
    const version = context.gModel.getDbVersion();

    if (version !== undefined || !context.gModel) {
        return asyncDone(null, context);
    }

    return context.db.client.exec('select version from "SYS"."M_DATABASE"', function (err, rows) {
        if (err) {
            return asyncDone(new SqlError(context, err), context);
        }

        if (rows && rows[0] && rows[0].VERSION) {
            const version = rows[0].VERSION;
            context.logger.info('xsodata', 'db version: ' + version);
            context.gModel.setDbVersion(version);
        } else {
            context.gModel.setDbVersion(null); // don't try reload
        }

        return asyncDone(null, context);
    });
}

/**
 * Sets the schema and isolation level on the current db connection
 *
 * @param context
 * @param asyncDone
 */
function prepareConnection(context, asyncDone) {
    context.logger.debug('db','prepareConnection');
    let executeList = [
        utils.injectContext(context)
    ];

    // Set the default schema
    if (context.defaultSchema) {
        executeList.push(utils.tryAndMeasure(execSQL, 'SET SCHEMA ' + context.defaultSchema, 'execSQL (default schema)'));
    }


    // Set the isolation level
    executeList.push(utils.tryAndMeasure(execSQL, 'SET TRANSACTION ISOLATION LEVEL REPEATABLE READ', 'execSQL (isolation level)'));
    executeList.push(loadDbVersion);

    async.waterfall(
        executeList,
        function (err) {
            context.db.client.setAutoCommit(false);
            asyncDone(err, context);
        }
    );
}

/**
 * Calls the callback function used by the application to open the cb connection only on demand
 *
 * @param context
 * @param asyncDone
 * @private
 */
exports._openConnection = function (context, asyncDone) {
    context.logger.debug('db','_openConnection');
    context.db.opener(context.handlerConfiguration.dbConfiguration, function (err, newClient) {
        if (err) {
            return asyncDone(new ApplicationError('Internal error occurred', err), context);
        }
        context.db.client = newClient;

        return prepareConnection(context, asyncDone);
    });
};


/**
 * Connects to a database, there are 3 way to define which database
 * 1. By providing a hdbClient via requestOptions.dbClient
 * 2. By providing a callback function to open the connection via requestOptions.dbOpenCB
 * 3. By providing the dbConfiguration which is passed to the hdb module
 *
 * @param context
 * @param asyncDone
 * @returns {*}
 * @private
 */
function _connectInternal(context, asyncDone) {
    let client;
    let child;
    context.logger.debug('db', '_connectInternal');
    context.db.isExternalHandledConnection = false;
    if (context.db) {
        if (context.db.client) {
            //use existing db client
            context.logger.debug('db', 'use existing db client');
            context.db.isExternalHandledConnection = true; // indicator for temp table truncation/drop
            return prepareConnection(context, asyncDone);
        } else if (context.db.opener) {
            context.logger.debug('db', 'use opener');
            context.db.isExternalHandledConnection = true; // indicator for temp table truncation/drop
            return exports._openConnection(context, asyncDone);
        }
    }


    try {
        context.logger.silly('db', 'use hdb.createClient');
        client = Measurement.measureSync(hdb.createClient, context.handlerConfiguration.dbConfiguration, 'hdb.createClient');

    } catch (exception) {
        context.logger.error('db', 'createClient failed: ' + JSON.stringify(exception));
        return asyncDone(exception, context);
    }

    client.on('error', function (err) {
        context.logger.error('db', 'client error event: ' + JSON.stringify(err));
        return asyncDone(new InternalError(err, context), context);
    });

    if (Measurement.isActive()) {
        /* perform an explicit measurement:
         * extract the current parent from the global stack
         * assign a new child: implicitly starts a counter, is used later to stop the counter
         */
        let parent = Measurement.getRunningMeasurement();
        child = parent.newChild('client.connect');
        child.counterStart();
    }

    client.connect(function (err) {
        context.logger.info('db', 'client.connect done');
        if (Measurement.isActive()) {
            child.counterStop();
        }

        if (err) {
            context.logger.error('db', 'connect failed: ' + JSON.stringify(err));
            client.end();
            return asyncDone(new InternalError(err, context), context);
        }

        context.db.client = client;
        context.db.openedConnection = true;


        context.logger.info('db', 'connection opened');


        return prepareConnection(context, asyncDone);
    });
}

/**
 * Open and configures the db connection
 *
 * @param context
 * @param asyncDone
 * @returns {*}
 */
exports.connect = function (context, asyncDone) {
    context.logger.debug('db', 'connect');
    context.db = context.db || {};
    if (context.db.client && (context.db.connectionInitialized === true)) {
        return asyncDone(null, context);
    }

    locks.writeLock('db_open', function (release) {
        return _connectInternal(context, function (err) {
            context.logger.debug('db', 'connection is usable');
            context.db.connectionInitialized = true;
            release();
            return asyncDone(err, context);
        });

    });
};


/**
 * Ends the db connection
 *
 * @param context
 */
exports.disconnect = function (context) {
    context.logger.info('db', 'disconnect');
    context.db = context.db || {};
    if (context.db.openedConnection) {
        context.logger.info('db', 'disconnect done');
        if (context.db.client) {
            context.db.client.end();
        }
        context.db.openedConnection = false;
    }
};


exports.dbRollback = (context, dbClient, cb) => {
    context.logger.info('db', 'dbRollback');
    return dbClient.rollback(function (errDB) {
        if (errDB) {
            //Error in rollback ends whole request
            return cb(errDB);
        }

        if (dbVersionChecks.shouldNotCleanTmpTables(context)) {
            context.logger.info('db', 'no tmp table delete due to rollback');
            tableCleanup.emptyLists(context);
        }

        return cb();
    });
};
