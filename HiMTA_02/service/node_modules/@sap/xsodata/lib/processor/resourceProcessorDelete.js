'use strict';
var async = require('async');

var connect = require('../db/connect');
var utils = require('./../utils/utils');
var contentIdHelper = require('./contentIdHelper');
var sqlDelete = require('./../sql/createDeleteStatements');
var dataCollectorDelete = require('./../sql/dataCollectorDelete');
var serializer = require('./../serializer/serializer');
var exitProcessor = require('./exitProcessor');
var Http404_NotFound = require('./../utils/errors/http/notFound');

function eventBefore(context, asyncDone) {
    context.logger.info('delete', 'event start before');
    var eventFunction = exitProcessor.eventHandler('before', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'before');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventAfter(context, asyncDone) {
    context.logger.info('delete', 'event start after');
    var eventFunction = exitProcessor.eventHandler('after', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'after');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPrecommit(context, asyncDone) {
    context.logger.info('delete', 'event start precommit');
    var eventFunction = exitProcessor.eventHandler('precommit', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'precommit');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPostCommit(context, asyncDone) {
    context.logger.info('delete', 'event start postcommit');
    var eventFunction = exitProcessor.eventHandler('postcommit', 'delete');
    eventFunction(context, function (err, context) {
        context.logger.info('delete event end', 'postcommit');
        if (err) {
            context.logger.info('delete event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}


function executeDelete(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var _delete = (entityType.modifications || {})['delete'] || {};
    if (_delete.using) {
        exitProcessor.executeExit(_delete.using, 'using', 'delete', context, asyncDone);
    } else {
        dataCollectorDelete.deleteTable(context, asyncDone);
    }
}

function commit(context, asyncDone) {
    return dataCollectorDelete.commit(context, asyncDone);
}

/**
 * dataCollectorDelete.insertDataToDelTable fetches the entity to be deleted, and inserts it into a temp table.
 * It calls dataCollector.execParallelNoResultwithParam, which asynchronously returns
 * asyncDone(err, context, affectedRows)
 * Therefore, before starting the execution, this function checks the affectedRows of the fetched temp entity
 * */
function checkExistence(context, affectedRows, asyncDone) {
    if (affectedRows === 0) {
        return asyncDone(new Http404_NotFound('The specified entity to be deleted does not exist.'), context);
    }
    return asyncDone(null, context);
}

exports.process = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDelete', 'process');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDelete.createDeleteStatementsForCreateTmpTables),
            utils.try(dataCollectorDelete.createTmpTables),
            utils.try(contentIdHelper.createNewContentIdFromRecordMapFromPayload),
            utils.try(sqlDelete.createDeleteStatementsForDelete),
            utils.try(dataCollectorDelete.insertDataToDelTable),
            utils.try(checkExistence),

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(commit),
            utils.try(eventPostCommit),

            // cleanup
            utils.try(dataCollectorDelete.truncateTempTables),
            utils.try(dataCollectorDelete.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],
        function (err, context) {
            if (err) {
                var dbClient = context.db.client;
                if (dbClient) {
                    //ROLLBack the changes
                    return connect.dbRollback(context, dbClient, function (errDB) {
                        if (errDB) {
                            return asyncDone(errDB, context);
                        }

                        return asyncDone(err, context);
                    });
                }
            }
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchCreateTables = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDelete', 'processInBatchCreateTables');

    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(sqlDelete.createDeleteStatementsForCreateTmpTables),
            utils.try(dataCollectorDelete.createTmpTables),
            utils.try(contentIdHelper.createNewContentIdFromRecordMapFromPayload)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatch = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDelete', 'processInBatch');

    async.waterfall(
        [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDelete.createDeleteStatementsForDelete),
            utils.try(dataCollectorDelete.insertDataToDelTable),
            utils.try(checkExistence),

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete),
            utils.try(eventAfter)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchPreCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDelete', 'processInBatchPreCommitRun');
    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPrecommit)
        ],

        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchPostCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDelete', 'processInBatchPostCommitRun');
    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPostCommit),

            // cleanup
            utils.try(dataCollectorDelete.truncateTempTables),
            utils.try(dataCollectorDelete.dropTempTables),

            // postprocessing
            utils.try(serializer.serializeNoContent)
        ],

        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
