'use strict';

var async = require('async');
var connect = require('../db/connect');
var sqlPutPostLinks = require('./../sql/createPutPostLinksStatements');
var dataCollectorLinks = require('./../sql/dataCollectorLinks');
var dataCollectorPutPostLinks = require('./../sql/dataCollectorPutPostLinks');
var DBSegment = require('./../db/dbSegment');
var serializer = require('./../serializer/serializer');
var exitProcessor = require('./exitProcessor');
var utils = require('./../utils/utils');
var contenTypeCheck = require('./../utils/checkContentType');


var UnsupportedMediaType = require('./../utils/errors/http/unsupportedMediaType');
var BadRequest = require('./../utils/errors/http/badRequest');

function movePayloadToDbSegment(context, asyncDone) {

    var req = context.request;
    var contentType = req.headers['content-type'];

    try {
        context.logger.silly('resourceProcessorPutPostLinks', 'movePayloadToDbSegment');

        if (contentType) {
            if (!contenTypeCheck.isSupportedContentType(contentType)) {
                throw new UnsupportedMediaType('Content-Type ' + contentType + ' not supported.');
            }
        }

        if (req.body) {
            //SAPINFO This IF covers the Express case. The Express module sets the body in the request object
            onData(req.body);
        } else {
            req.getBodyAsString(onData);
        }
    } catch (err) {
        return asyncDone(err, context);
    }

    function onData(buffer) {
        var data,
            json;

        try {
            data = buffer.toString('utf-8');

            if (contenTypeCheck.isContentTypeJson(contentType) === true) {

                try {
                    json = JSON.parse(data);
                } catch (e) {
                    return asyncDone(new BadRequest("Request payload is not a valid JSON object", context), context);
                }
                utils.validateAndSetLinksPayload(json, context.oData.dbSegmentLast, context.uriTree.baseUrl);

                if (!context.oData.dbSegmentLast.m2n) {
                    DBSegment.DbSegment.setRecordPutPostLinks(context);
                }

                return asyncDone(null, context);
            }

            // If we reach this code no valid content type could be found
            // or the payload is not valid
            throw new UnsupportedMediaType('Content-Type ' + contentType + ' does not match payload: ' + data);

        } catch (err) {
            return asyncDone(err, context);
        }
        return asyncDone(null, context);
    }

}


function eventBefore(context, asyncDone) {
    context.logger.info(context.oData.links.sOperation, 'event start before');
    var eventFunction = exitProcessor.eventHandler('before', context.oData.links.sOperation);
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'before');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventAfter(context, asyncDone) {
    context.logger.info(context.oData.links.sOperation, 'event start after');
    var eventFunction = exitProcessor.eventHandler('after', context.oData.links.sOperation);
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'after');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPrecommit(context, asyncDone) {
    context.logger.info(context.oData.links.sOperation, 'event start precommit');
    var eventFunction = exitProcessor.eventHandler('precommit', context.oData.links.sOperation);
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'precommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPostCommit(context, asyncDone) {
    context.logger.info(context.oData.links.sOperation, 'event start postcommit');
    var eventFunction = exitProcessor.eventHandler('postcommit', context.oData.links.sOperation);
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'postcommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function insertTmpTableToRealTable(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var create = (entityType.modifications || {}).update || {};

    if (create.using) {
        exitProcessor.executeExit(create.using, 'using', context.oData.links.sOperation, context, asyncDone);
    } else {
        dataCollectorLinks.insertTmpTableToRealTable(context, asyncDone);
    }
}

function insertTmpTableToRealMNTable(context, asyncDone) {
    var dbSeg = context.oData.links.toBeUpdated;

    var entityType = dbSeg.entityType;
    var create = (entityType.modifications || {}).create || {};
    if (create.using) {
        exitProcessor.executeExit(create.using, 'using', 'create', context, asyncDone);
    } else {
        dataCollectorPutPostLinks.insertTmpTableToRealMNTable(context, asyncDone);
    }
}

function setStatus(context, asyncDone) {
    context.response.status(204);
    return asyncDone(null, context);
}

exports.process = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPutPostLinks', 'process');

    // Adapt the operation that is passed to the custom exit handler
    if (context.request.method === "POST") {
        context.oData.links.sOperation = 'create';
    } else if (context.request.method === "PUT") {
        context.oData.links.sOperation = 'update';
    }

    var execArr;
    var m2n = (context.oData.dbSegmentLast.getOver() !== undefined);
    if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlPutPostLinks.createPutPostLinksMNStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTableMN), //create //NEW ORL
            //utils.try(contentIdHelper.createNewContentIdFromRecordMapFromPayload),

            utils.try(movePayloadToDbSegment),
            utils.try(sqlPutPostLinks.createPutPostLinksMNStatementsInsert),

            utils.try(dataCollectorLinks.movePayloadFromMNSegmentToSelectStm), //no change
            // no auto key gen usage here
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealMNTable), //insert real
            utils.try(eventAfter),

            //post processing
            //utils.try(dataCollectorLinks.selectData), //select

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorLinks.commit),
            utils.try(eventPostCommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorLinks.truncateTempTablesMN),

            // drop temporary tables to clean the session
            utils.try(dataCollectorLinks.dropTempTablesMN),

            //utils.try(modifyDbSegment),
            //utils.try(writeLocationHeader),
            //utils.try(serializer.serializeData),
            utils.try(setStatus)
        ];
    } else {
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlPutPostLinks.createPutPostLinksStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTables), //create //NEW ORL
            //utils.try(contentIdHelper.createNewContentIdFromRecordMapFromPayload),

            utils.try(movePayloadToDbSegment),
            utils.try(sqlPutPostLinks.createPutPostLinksStatementsInsert),

            utils.try(dataCollectorLinks.moveRecordNV_ToSelectStm), //no change
            // no auto key gen usage here
            utils.try(dataCollectorLinks.insertOldDataToOldTable),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorLinks.commit),
            utils.try(eventPostCommit),

            // cleanup
            utils.try(dataCollectorLinks.truncateTempTables),
            utils.try(dataCollectorLinks.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            if (err) {
                var dbClient = context.db.client;
                if (dbClient) {
                    //ROLLBack the changes
                    return connect.dbRollback(context, dbClient, function (errDB) {
                        if (errDB) {
                            return asyncDone(errDB, context);
                        }

                        return asyncDone(err, context);
                    });
                }
            }
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchCreateTables = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPutPostLinks', 'processInBatchCreateTables');

    var execArr;
    var m2n = (context.oData.dbSegmentLast.getOver() !== undefined);
    if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            utils.try(sqlPutPostLinks.createPutPostLinksMNStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTableMN), //create //NEW ORL
            //utils.try(contentIdHelper.createNewContentIdFromRecordMapFromPayload),
        ];
    }
    else {
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlPutPostLinks.createPutPostLinksStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTables), //create //NEW ORL
            //utils.try(contentIdHelper.createNewContentIdFromRecordMapFromPayload),


        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatch = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPutPostLinks', 'processInBatch');

    var execArr;
    var m2n = (context.oData.dbSegmentLast.getOver() !== undefined);
    if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),
            utils.try(movePayloadToDbSegment),
            utils.try(sqlPutPostLinks.createPutPostLinksMNStatementsInsert),

            utils.try(dataCollectorLinks.movePayloadFromMNSegmentToSelectStm), //no change
            // no auto key gen usage here

            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealMNTable), //insert real
            utils.try(eventAfter)

            //post processing
            //utils.try(dataCollectorLinks.selectData), //select
        ];
    }
    else {
        execArr = [
            utils.injectContext(context),
            utils.try(movePayloadToDbSegment),
            utils.try(sqlPutPostLinks.createPutPostLinksStatementsInsert),
            //utils.try(contentIdHelper.createNewContentIdFromRecordMapFromPayload),

            utils.try(dataCollectorLinks.moveRecordNV_ToSelectStm), //no change

            utils.try(dataCollectorLinks.insertOldDataToOldTable),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter)
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchPreCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPutPostLinks', 'processInBatchPreCommitRun');

    async.waterfall(
        [
            utils.injectContext(context),

            //commit handling
            utils.try(eventPrecommit)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchPostCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorPutPostLinks', 'processInBatchPostCommitRun');

    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPostCommit),

            // truncate temporary tables to clean the session
            utils.try(dataCollectorLinks.truncateTempTables),

            // drop temporary tables to clean the session
            utils.try(dataCollectorLinks.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
