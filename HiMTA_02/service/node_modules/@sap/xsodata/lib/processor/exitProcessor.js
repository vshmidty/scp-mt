'use strict';

const _ = require('lodash');
const HttpError = require('./../utils/errors/httpError');
const SqlError = require('../utils/errors/sqlError');

var EXIT_REGEXP = /([\w\.\/\-]+)(:((\w+)\.(js|xsjslib)))?::(\w+)/;

module.exports = {
    ExitSpec: ExitSpec,
    eventHandler: eventHandler,
    executeExit: executeExit
};

function ExitSpec(sExitSpec) {
    var aMatch = EXIT_REGEXP.exec(sExitSpec);

    function throwMalformedSpec() {
        throw new Error('Invalid exit specification ' + sExitSpec +
            '. Expected format package.package:file.ext::function');
    }

    if (!aMatch) {
        throwMalformedSpec();
    }

    this.package = aMatch[1];
    this.file = aMatch[4];
    this.ext = aMatch[5];
    this.functionName = aMatch[6];

    if (!this.functionName) {
        throwMalformedSpec();
    }
}

/**
 * @param sEventType  : string, one of before, after, precommit, postcommit
 * @param sOperation : string, one of create, update, delete
 * @returns {Function} ready to be plugged in the async waterfall
 */
function eventHandler(sEventType, sOperation) {
    return function callEventHandler(context, asyncDone) {
        var modifications; // The defined modifications (custom exits) of the given odata service entry (association | entityType)
        var association, entityType;
        var operation, modelExitSpec;
        var foundEvent;

        // if links, e.g. /Employees('1')/$links/ne_Team, modifications are given in the in-xsodata-defined association (TeamEmployees)
        if (context.oData.dbSegment && context.oData.dbSegment.isLinks) {
            // extract the corresponding association, then its modifications
            association = context.oData.links.association;
            modifications = association.modification || {};
        }
        // otherwise, modifications belong to the single given entityType
        else {
            // extract the corresponding entityType, then its modifications
            entityType = context.oData.dbSegmentLast.entityType;
            modifications = entityType.modifications || {};
        }

        operation = modifications[sOperation] || {};
        if (operation.events) {
            foundEvent = _.find(operation.events, function (event) {
                return event.type === sEventType;
            });
            if (foundEvent) {
                modelExitSpec = foundEvent;
            }
        }

        if (modelExitSpec) {
            executeExit(modelExitSpec.action, sEventType, sOperation, context, asyncDone);
        } else {
            return asyncDone(null, context);
        }
    };
}

/**
 *
 * @param sExitSpec is exit spec as string, for example my_package.my_subpackage:my_file.xsjslib::my_function
 * @param sEventType is a string, one of 'using','before','after', 'precommit', 'postcommit'
 * @param sOperation is a string, one of 'create','update','delete'
 * @param context  is the odata context
 * @param asyncDone is the async framework callback
 */
function executeExit(sExitSpec, sEventType, sOperation, context, asyncDone) {
    try {
        _executeExit(sExitSpec, sEventType, sOperation, context, asyncDone);
    } catch (x) {
        return asyncDone(x, context);
    }
}

function _executeExit(sExitSpec, sEventType, sOperation, context, asyncDone) {
    var exitSpec = new ExitSpec(sExitSpec);

    var dbSegment = context.oData.dbSegmentLast;
    var attribute1name; // afterTableName | (if links) principalTableName
    var table1name; // the corresponding table name for attrib.1
    var attribute2name; // beforeTableName | (if links) dependentTableName
    var table2name; // the corresponding table name for attrib.2

    var param = {}, aParams = [];

    if (context.oData.dbSegment && context.oData.dbSegment.isLinks) {
        dbSegment = context.oData.links.toBeUpdated;
        attribute1name = "principalTableName";
        table1name = dbSegment.sql.rIdPrincipal;
        attribute2name = "dependentTableName";
        table2name = dbSegment.sql.rIdDependent;
    } else {
        dbSegment = context.oData.dbSegmentLast;
        attribute1name = "afterTableName";
        table1name = dbSegment.sql.rId || dbSegment.sql.rIdNew;
        attribute2name = "beforeTableName";
        table2name = dbSegment.sql.rIdOld;
    }


    if (exitSpec.file) {
        //script reference

        param[attribute1name] = table1name;
        param[attribute2name] = table2name;

        context.functionExecutor(exitSpec, param, function (err, result) {
            // Custom exits return errors of a specific format (DevGuid, SPS10, Table75, Page494)
            // if so, returned error must be reformatted
            if (err) {
                return asyncDone(new HttpError(err.ERROR_MESSAGE || 'Internal Server Error', context, null, err.HTTP_STATUS_CODE || 500, err), context);
            }
            if (result && result !== true) {
                return asyncDone(new HttpError(result.ERROR_MESSAGE || 'Internal Server Error', context, null, result.HTTP_STATUS_CODE || 500, result), context);
            }
            return asyncDone(null, context);
        });

    } else {
        //sql procedure reference
        var dbClient = context.db.client;
        table1name = '"' + table1name + '"';
        table2name = '"' + table2name + '"';

        switch (sOperation) {
            case 'create' :
            {
                aParams = [table1name];
                break;
            }
            case 'update' :
            {
                aParams = [table1name, table2name];
                break;
            }
            case 'delete' :
            {
                aParams = [table2name];
                break;
            }
        }

        if (sEventType !== 'postcommit') {
            aParams.push('?');
        }

        var sParams = aParams.join(',');

        var sql = 'call "' + sExitSpec + '"(' + sParams + ')';

        dbClient.prepare(sql, function (err, statement) {
            if (err) {
                return asyncDone(new SqlError(context, err), context);
            } else {
                statement.exec({}, function (err, scalarParams, outTable) {
                    if (err) {
                        return asyncDone(new SqlError(context, err), context);
                    } else {
                        if (outTable.length > 0) {
                            var appError = outTable[0];
                            var statusCode = appError.HTTP_STATUS_CODE;
                            var errorMessage = appError.ERROR_MESSAGE;
                            var innerError = JSON.stringify(appError);
                            err = new HttpError(errorMessage, context, null, statusCode, innerError);
                        }
                        return asyncDone(err, context);
                    }
                });
            }
        });
    }
}
