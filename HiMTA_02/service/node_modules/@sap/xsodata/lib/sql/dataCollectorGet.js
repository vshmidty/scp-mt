'use strict';

//Include
const async = require('async');
const dataCollector = require('./dataCollector');
const sqlStatement = require('./sqlStatement');
const utils = require('../utils/utils');
const SqlError = require('../utils/errors/sqlError');

exports.createTmpTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'createTmpTables');
    var container = context.sql.container;
    var stms = [];
    var i;

    for (i = 0; i < container.createTmp.length; i++) {
        stms.push(container.createTmp[i].stm);
    }
    return dataCollector.execParallelNoResult(stms, context, asyncDone);

};


exports.insertFillTmpTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'insertFillTmpTables');
    var client = context.db.client;

    var container = context.sql.container;
    var stms = container.insertTmp;

    async.mapSeries(stms,
        function (item, cb) {
            try {
                var p = [];
                var sql = item.stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);
                context.logger.debug('SQL Exec', 'SQL: \n' + sql);
                client.prepare(sql, function (err, statement) {
                    if (err) {
                        context.logger.info('SQL Exec', 'Error: \n' + err);
                        context.logger.info('SQL Exec', 'SQL: \n' + sql);
                        return cb(new SqlError(context, err));
                    }

                    context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                    statement.execute(p, function (err/*, rows*/) {
                        if (err) {
                            context.logger.info('SQL Exec', 'Error: \n' + err);
                            context.logger.info('SQL Exec', 'SQL: \n' + sql);
                            context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                            return cb(new SqlError(context, err));
                        }
                        return cb();
                    });
                });
            } catch (ex) {
                return cb(ex);
            }
        }, function (err/*, results*/) {
            if (err) {
                return asyncDone(err, context);
            }
            return asyncDone(null, context);
        }
    );
};


exports.select = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'select');

    var client = context.db.client;
    var container = context.sql.container;
    var stms = container.select.concat(container.selectTmp);

    async.mapSeries(stms,
        function (item, cb) {
            try {
                execStatement(item, function (err, rows) {
                    if (err) {
                        return cb(err);
                    }

                    if (rows.length === 0 && item.stm.getFallbackStatement && item.stm.getFallbackStatement()) {
                        return execStatement({
                            stm: item.stm.getFallbackStatement(),
                            dbSeg: item.dbSeg
                        }, cb, true);
                    }

                    return cb(null, rows);
                });
            } catch (ex) {
                cb(ex);
            }
        }, function (err) {
            if (err) {
                return asyncDone(err, context);
            }
            return asyncDone(err, context);
        }
    );


    function execStatement(item, cb, count) {
        let p = [];

        context.logger.debug('dataCollector', 'count fallback: ' + !!count);
        context.logger.silly('dataCollector', 'pre to hana');
        let sql = item.stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);

        context.logger.debug('SQL Exec', 'SQL: \n' + sql);
        client.prepare(sql, function (err, statement) {
            if (err) {
                context.logger.info('SQL Exec', 'Error: \n' + err);
                context.logger.info('SQL Exec', 'SQL: \n' + sql);
                return cb(new SqlError(context, err));
            }

            context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
            statement.exec(p, function (err, rows) {
                if (err) {
                    if (count) {
                        return CalcViewCallback(item, context, cb);
                    } else {
                        context.logger.info('SQL Exec', 'Error: \n' + err);
                        context.logger.info('SQL Exec', 'SQL: \n' + sql);
                        context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                        return cb(new SqlError(context, err));


                    }
                }

                if (!count) {
                    item.dbSeg.sql.rows = rows;
                    item.dbSeg.sql.countRows = [];

                    if (rows.length === 1 && utils.isETagHeaderRequired(context, item.dbSeg)) {
                        item.dbSeg.etagHeader = rows[0].__etag;
                    }
                } else {
                    item.dbSeg.sql.rows = [];
                    item.dbSeg.sql.countRows = rows;
                }

                context.logger.silly('dataCollector', JSON.stringify(rows.length));
                context.logger.silly('dataCollector', JSON.stringify(rows, null, 2));
                return cb(null, rows);
            });
        });
    }
};

let CalcViewCallback = function (item, context, cb) {
    // try workaround for calcviews with transparent filters
    if (!item.stm.froms || !item.stm.froms[0]) {
        return cb(new Error('Calcview fallback failed'));
    }

    let client = context.db.client;
    let subStatement = item.stm.froms[0].subQuery;
    let p = [];
    let sql = subStatement.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);

    let start = 0;
    let top = 10;

    let readNext = true;
    let rowcount = 0;

    async.whilst(
        function () { return readNext; },
        function (callback) {
            let sqlIter = sql + " LIMIT " + top + ' OFFSET ' + start;
            context.logger.debug('SQL Exec CBF', 'SQL: \n' + sqlIter);
            return client.prepare(sqlIter, function (err, statement) {
                if (err) {
                    context.logger.info('SQL Exec CBF', 'Error: \n' + err);
                    context.logger.info('SQL Exec CBF', 'SQL: \n' + sql);
                    return callback(new SqlError(context, err));
                }
                return statement.exec(p, function (err, rows) {
                    if (err) {
                        context.logger.info('SQL Exec CBF', 'Error: \n' + err);
                        context.logger.info('SQL Exec CBF', 'SQL: \n' + sql);
                        context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                        return cb(new SqlError(context, err));
                    }

                    if (rows.length === 0) {
                        readNext = false; //exit
                    } else {
                        rowcount += rows.length;
                    }
                    start += top;
                    return callback(null, start);
                });
            });


        },
        function (err, start) {
            if (err) {
                context.logger.info('SQL Exec CBF', 'Error: \n' + err);
                context.logger.info('SQL Exec CBF', 'at iteration' + start);
                return cb(err);
            }
            item.dbSeg.sql.countRows = [{ 'c': rowcount }];
            return cb(null, item.dbSeg.sql.countRows);
        }
    );


};


/**
 * Executes SQL SELECT statement.
 *
 * @param {Object} context - OData context
 * @param {Object} selectStmt - instance of Select "class" from sqlStatement.js
 * @param {Function} callback - callback, which should be called once the operation is completed
 */
exports.executeSelect = function executeSelect(context, selectStmt, callback) {
    var client = context.db.client,
        parameters = [],
        sql;

    try {
        sql = selectStmt.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), parameters);
    } catch (e) {
        return callback(e);
    }

    context.logger.debug('executeSelect', 'SQL: \n' + sql);
    client.prepare(sql, function (err, statement) {
        if (err) {
            context.logger.info('executeSelect', 'Error: \n' + err);
            context.logger.info('executeSelect', 'SQL: \n' + sql);
            return callback(new SqlError(context, err));
        }

        context.logger.debug('executeSelect', 'Parameters:\n' + JSON.stringify(parameters));
        statement.exec(parameters, function (err, rows) {
            if (err) {
                context.logger.info('executeSelect', 'Error: \n' + err);
                context.logger.info('executeSelect', 'SQL: \n' + sql);
                context.logger.info('executeSelect', 'Parameters:\n' + JSON.stringify(parameters));
                return callback(new SqlError(context, err));
            }

            callback(null, rows);
        });
    });
};

/**
 * Executes truncation of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.truncateTempTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'truncateTempTables');
    return dataCollector.execTempTableStatements(context.sql.cleanSessionTruncateContainer, context, (err, context) => {
        if (err) {
            context.logger.silly('dataCollectorGet', 'truncateTempTables rc !=0 but OK');
        }
        return asyncDone(null, context);
    });
};

/**
 * Executes deletion of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.dropTempTables = function (context, asyncDone) {
    context.logger.silly('dataCollectorGet', 'dropTempTables');
    return dataCollector.execTempTableStatements(context.sql.cleanSessionDropContainer, context, (err, context) => {
        if (err) {
            context.logger.silly('dataCollectorGet', 'dropTempTables rc !=0 but OK');
        }
        return asyncDone(null, context);
    });

};
