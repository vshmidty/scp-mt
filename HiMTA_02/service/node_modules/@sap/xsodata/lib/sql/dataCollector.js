'use strict';

//Include
const async = require('async');
const sqlStatement = require('./sqlStatement');

const InternalError = require('./../utils/errors/internalError');
const NotFoundError = require('./../utils/errors/http/notFound');
const SqlError = require('../utils/errors/sqlError');

exports.insertToTempTable = function (context, asyncDone) {
    context.logger.silly('dataCollector', 'insertToTempTable');
    var client = context.db.client;
    var sqlContext = context.sql;
    var stm = sqlContext.sqlStatments.insertTmp[0].stm;
    var p = [];
    var sql = stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);

    context.logger.debug('SQL Exec', 'SQL: \n' + sql);
    client.prepare(sql, function (err, statement) {
        if (err) {
            context.logger.info('SQL Exec', 'Error: \n' + err);
            context.logger.info('SQL Exec', 'SQL: \n' + sql);
            return asyncDone(new SqlError(context, err), context);
        }

        context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
        statement.exec(p, function (err) {
            if (err) {
                context.logger.info('SQL Exec', 'Error: \n' + err);
                context.logger.info('SQL Exec', 'SQL: \n' + sql);
                context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                return asyncDone(new SqlError(context, err), context);
            }
            return asyncDone(null, context);
        });
    });
};

exports.insertToRealTable = function (context, asyncDone) {
    context.logger.silly('dataCollector', 'insertToRealTable');
    var client = context.db.client;
    var sqlContext = context.sql;
    var stm = sqlContext.sqlStatments.insertsSequential[0].stm;
    var p = [];
    var sql = stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);
    context.logger.debug('SQL Exec', 'SQL: \n' + sql);
    client.prepare(sql, function (err, statement) {
        if (err) {
            context.logger.info('SQL Exec', 'Error: \n' + err);
            context.logger.info('SQL Exec', 'SQL: \n' + sql);
            return asyncDone(new SqlError(context, err), context);
        }

        context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
        statement.exec(p, function (err) {
            if (err) {
                context.logger.info('SQL Exec', 'Error: \n' + err);
                context.logger.info('SQL Exec', 'SQL: \n' + sql);
                context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                return asyncDone(new SqlError(context, err), context);
            }
            return asyncDone(null, context);
        });
    });

};

exports.execParallelNoResult = function (stms, context, asyncDone) {
    context.logger.silly('dataCollector', 'execParallelNoResult');
    var client = context.db.client;

    async.mapSeries(stms,

        function (item, cb) {
            try {
                var p = [];
                var sql = item.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);
                if (p.length > 0) {
                    return cb(new InternalError('No sql parameters expected'), context);
                }

                context.logger.silly('SQL Exec', 'SQL: \n' + sql);
                client.exec(sql, function (err) {
                    if (err) {
                        context.logger.info('SQL Exec', 'Error: \n' + err);
                        context.logger.info('SQL Exec', 'SQL: \n' + sql);
                        return cb(new SqlError(context, err));
                    }
                    return cb();
                });
            } catch (ex) {
                cb(ex);
            }
        }, function (err) {
            return asyncDone(err, context);
        }
    );
};

exports.execParallelNoResultwithParam = function (stms, context, asyncDone, provideAffectedRows) {
    context.logger.silly('dataCollector', 'execParallelNoResult');
    var client = context.db.client;

    async.mapSeries(stms,

        function (item, cb) {
            try {
                var p = [];
                var sql = item.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);

                context.logger.debug('SQL Exec', 'SQL: \n' + sql);
                client.prepare(sql, function (err, statement) {
                    if (err) {
                        context.logger.info('SQL Exec', 'Error: \n' + err);
                        context.logger.info('SQL Exec', 'SQL: \n' + sql);
                        return cb(new SqlError(context, err));
                    }

                    context.logger.debug('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                    statement.execute(p, function (err, rows) {
                        context.logger.info('SQL Exec', 'Rows: \n' + JSON.stringify(rows));
                        if (err) {
                            context.logger.info('SQL Exec', 'Error: \n' + err);
                            context.logger.info('SQL Exec', 'SQL: \n' + sql);
                            context.logger.info('SQL Exec', 'Parameters:\n' + JSON.stringify(p));
                            return cb(new SqlError(context, err));
                        }
                        cb(null, rows);
                    });
                });
            } catch (ex) {
                cb(ex);
            }
        }, function (err, rows) {
            if (provideAffectedRows === true) {
                if (rows && Array.isArray(rows) && rows.length > 0) {
                    return asyncDone(err, context, rows[0]);
                } else {
                    return asyncDone(err, context, 0);
                }
            } else {
                return asyncDone(err, context);
            }
        }
    );
};

exports.getAffectedRowsValidator = function (expectedAffectedRows, asyncDone) {

    return (function (expectedAffectedRows, asyncDone) {

        return function (err, context, affectedRows) {
            if (err) {
                return asyncDone(err, context);
            }

            if (affectedRows !== expectedAffectedRows) {
                return asyncDone(new NotFoundError("Could not modify resource. Resource does not exist"), context);
            }
            asyncDone(null, context);
        };

    })(expectedAffectedRows, asyncDone);
};


/**
 * Removes matching statements from global temp tables statement list and
 * delegates the execution of the statements.
 *
 * @param {Object[]} stmts The statements to execute
 * @param {Object} context  The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.execTempTableStatements = function (stmts, context, asyncDone) {
    var index;
    context.logger.silly('dataCollector', 'execTempTableStatements');
    context.logger
        .debug('dataCollector', 'execTempTableStatements statements', JSON.stringify(stmts, null, 2));

    return exports.execCleanSessionStatements(stmts, context, function done(err, context) {

        if (err) {
            // In case of an error with temp tables cleaning we do not want to remove the
            // temp tables from the global list for now.
            return asyncDone(err, context);
        }

        stmts.forEach(function (statement) {
            // If the statements are successfully we remove them from global list.
            // At the end of processing we check if there are still remaining statements.
            index = context.networkContext.cleanSessionTruncateContainer.indexOf(statement);
            if (index > -1) {
                context.networkContext.cleanSessionTruncateContainer.splice(index, 1);
            }
            index = context.networkContext.cleanSessionDropContainer.indexOf(statement);
            if (index > -1) {
                context.networkContext.cleanSessionDropContainer.splice(index, 1);
            }
        });

        return asyncDone(null, context);
    });
};

/**
 * Executes removing of temp table statements. The execution is done only if the connection
 * is external. Otherwise nothing is done
 *
 * @param {Object[]} stms The statements to execute
 * @param {Object} context  The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.execCleanSessionStatements = function execCleanSessionStatements(stms, context, asyncDone) {
    context.logger.silly('dataCollector',
        'execCleanSessionStatements (connectionIsExternal: ' + context.db.isExternalHandledConnection + ')');

    if (context.db.isExternalHandledConnection === true) {
        return exports.execParallelNoResult(stms, context, asyncDone);
    }

    return asyncDone(null, context);
};

