'use strict';
/**
 * Add  <__metadata> and <__schema> to each entity in <context.xsodata>
 * Uses  <context.xsodata>
 * @type {exports}
 */
const utils = require('./../utils/utils');
const async = require('async');
const Rwlock = require('rwlock');
const db = require('./../db/connect');
const locks = new Rwlock();
const model = require('./model');
const InternalError = require('./../utils/errors/internalError');
const NotFound = require('./../utils/errors/http/notFound');
const SqlError = require('../utils/errors/sqlError');
const EntityType = require('./entityType');
const Association = require('./association');
const _ = require('lodash');
const Measurement = require('./../utils/measurement');

function loadKeysForTable(context, entityType, cb) {
    context.logger.silly('model', 'loadKeysForTable for entity ' + entityType.name);

    var processRows = function (err, rows) {
        context.logger.silly('model', 'rows\n' + JSON.stringify(rows, null, 4));
        if (err) {
            return cb(new SqlError(context, err));
        }

        if (rows.length === 0) {
            return cb(new InternalError("Table object does not have a key. Add a primary key to the table or use a generated key.", context, null), context);
        }

        entityType.setKeyNames(rows.map(function toKeyNames(row) {
            return row.COLUMN_NAME;
        }));

        return cb(null, entityType);
    };

    var schema = entityType.schema || context.defaultSchema;

    var sql =
        "SELECT * from CONSTRAINTS " +
        "WHERE SCHEMA_NAME = '" + schema + "' AND TABLE_NAME = '" + entityType.tableName + "' AND IS_PRIMARY_KEY = 'TRUE' ORDER BY position";
    context.logger.debug('model', 'sql: ' + sql);
    context.db.client.exec(sql, processRows);
}


function loadTableInfo(context, entityType, tableStoreType, cb) {
    context.logger.silly("model", "loadTableInfo");

    var processRows = function (err, rows) {
        context.logger.silly('model', 'rows\n' + JSON.stringify(rows, null, 4));
        if (err) {
            return cb(new SqlError(context, err));
        }

        if (rows.length === 0) {
            return cb(new NotFound('No data found for ' + entityType.tableName + '.', context, ''));
        }

        context.logger.silly('model', 'create Metadata for entity ' + entityType.name + ' with ' + rows.length + ' rows');
        entityType.init(new model.Metadata(rows), rows[0].KIND, tableStoreType, context.logger);

        if (entityType.kind === model.entityKind.table) {
            if (entityType.keys.names.length > 0) {
                return cb(new InternalError("Keys cannot be specified for source as it is a table object.", context, null), context);
            } else {
                return loadKeysForTable(context, entityType, cb);
            }
        } else {
            var genKey = entityType.keys.generatedKey;
            if (!genKey && entityType.keys.names.length === 0) {
                return cb(new InternalError("Missing specification of keys for view.", context, null), context);
            } else {
                if (genKey) {
                    var overwrittenColumn = entityType.propertiesMap[entityType.keys.generatedKey];
                    if (!!overwrittenColumn) {
                        // Provided generated key overwrites an existing column
                        var msg = "Invalid generated key property '" + genKey + "'";
                        msg += " in definition '" + overwrittenColumn.TABLE_NAME + "'.";
                        msg += " The generated key would overwrite an existing property";
                        return cb(
                            new InternalError(msg, context, null),
                            context
                        );
                    }
                }
                return cb(null, entityType);
            }
        }

    };

    context.logger.silly("model", "loadTableInfo 2");
    var schema = entityType.schema || context.defaultSchema;
    // entityType.table is either a real table or a SQL view
    // So we need to lookup both: sys.table_columns and sys.view_columns
    // sys.columns is not usable due to access restrictions
    var sql =

        "SELECT " +
        "   TO_BIGINT(" + model.entityKind.table + ") kind, " +
        "   table_name, " +
        "   column_name, " +
        "   position, " +
        "   data_type_name, " +
        "   is_nullable, " +
        "   length, " +
        "   scale, " +
        "   default_value " +
        "FROM TABLE_COLUMNS " +
        "WHERE  schema_name = ? AND " +
        "       table_name = ? " +
        "UNION ALL " +
        "SELECT " +
        "   TO_BIGINT(" + model.entityKind.view + ") kind, " +
        "   view_name as table_name, " +
        "   column_name, " +
        "   position, " +
        "   data_type_name, " +
        "   is_nullable, " +
        "   length, " +
        "   scale, " +
        "   default_value " +
        "FROM VIEW_COLUMNS " +
        "WHERE  schema_name = ? AND " +
        "       view_name = ?  " +
        "ORDER BY position";

    var parameters = [schema, entityType.tableName, schema, entityType.tableName];

    context.logger.silly("model", "sql loadTableInfo: " + sql);
    context.logger.silly("model", "sql parameters: " + parameters);
    context.db.client.prepare(sql, function (err, statement) {
        if (err) {
            return cb(new SqlError(context, err));
        }
        statement.exec(parameters, processRows);
    });
}

function loadCalcViewInfo(context, entityType, cb) {
    /*
     Remark : it is not possible(or at least i was not able to) to execute a JOIN in a MDX SELECT
     */
    var schema = entityType.schema || context.defaultSchema;
    var sql = "select " +
        "SCHEMA_NAME," +
        "QUALIFIED_NAME," +
        "CATALOG_NAME," +
        "CUBE_NAME," +
        "COLUMN_NAME," +           // JOIN ON
        "MEASURE_AGGREGATOR," +    // 1, 2,3
        "MEASURE_AGGREGATABLE, " +
        "SEMANTIC_TYPE, " +
        "COLUMN_CAPTION, " +
        "DIMENSION_TYPE, " +
        "UNIT_COLUMN_NAME, " +
        "DESC_NAME " +
        "from _SYS_BI.BIMC_DIMENSION_VIEW_HDI " +
        "where SCHEMA_NAME = ? AND QUALIFIED_NAME = ?";


    function processRows(err, rows) {
        context.logger.silly('metadataReader', 'rows\n' + JSON.stringify(rows, null, 4));

        if (err) {
            return cb(new SqlError(context, err));
        }

        if (!rows.length) {
            return cb(null, null);
        }

        var cubeName = rows[0].CUBE_NAME;
        entityType.setCalculationView(rows, { cube: cubeName }, context.logger);

        entityType.resolveAggregates();

        var parameters = entityType.getParameters();
        if (parameters) {
            loadInputParameters(parameters, entityType, context, function (errInp/*, paramEntity*/) {
                if (errInp) {
                    return cb(errInp);
                }
                return cb(null, entityType);
            });
        } else {
            return cb(null, entityType);
        }
    }

    /*
     Example mapping :
     calc view === sap.hana.democontent.epm.models::BUYER
     SCHEMA_NAME  === "container schema name".
     QUALIFIED_NAME === "...::BUYER"

     */
    //var columnobj = entityType.tableName.replace(/\./g, '/');
    //var schema = context.defaultSchema;
    /*  WARNING WARNING */
    /*
     The current HANA version has a bug, and prepared statements are not working in mdx select.
     Hence i replaced prepared statement with direct sql statement.
     */


    context.db.client.prepare(sql, function (err, statement) {
        if (err) {
            return cb(new SqlError(context, err));
        } else {
            var parameters = [schema, entityType.tableName];
            statement.exec(parameters, processRows);
        }
    });
}

function loadInputParameters(parameters, entityType, context, cb) {
    // At the time this sql was developed SCHEMA_NAME == NULL
    var sql = 'select ' +
        'VARIABLE_NAME, ' +
        'COLUMN_TYPE_D, ' +
        'COLUMN_SQL_TYPE, ' +
        'MANDATORY, ' +
        'DESCRIPTION, ' +
        'DEFAULT_VALUE, ' +
        'SEMANTIC_TYPE, ' +
        'SELECTION_TYPE, ' +
        'MULTILINE, ' +
        '"ORDER" ' +
        'from _SYS_BI.BIMC_VARIABLE_VIEW_HDI where QUALIFIED_NAME = ? order by "ORDER"';

    context.logger.debug('metadataReader', 'loadInputParameters: ' + entityType.tableName);
    context.logger.silly("metadataReader", "sql loadInputParameters: " + sql);

    context.db.client.prepare(sql, function (error, statement) {
        if (error) {
            return cb(new SqlError(context, error));
        }

        statement.exec([entityType.tableName], function (err, rows) {
            context.logger.silly('metadataReader', 'rows\n' + JSON.stringify(rows, null, 4));

            if (err) {
                return cb(new SqlError(context, err));
            }

            if (!rows.length) {
                //No calc view parameters found
                return cb(new InternalError('No calc view parameters found for ' + entityType.name));
            }

            entityType.inputParameters = {};
            rows.forEach(function (row) {
                entityType.inputParameters[row.VARIABLE_NAME] = row;
            });

            try {
                var paramEntityType = loadInputParametersEntity(parameters, entityType, context, rows);
                if (parameters.viaKey) {
                    /*this is called */
                    loadInputParametersViaKey(entityType, paramEntityType, context);
                }
            } catch (err_process) {
                err = err_process;
            }

            return cb(err);
        });
    });
}

function loadInputParametersEntity(parameters, entityType, context, rows) {
    var paramEntityName = parameters.entity;
    if (!paramEntityName || paramEntityName.trim() === '') {
        //No name, use default naming
        paramEntityName = entityType.name + 'Parameters';
    }

    var resultsProp = parameters.resultProperty || 'Results';
    var assocName = paramEntityName + '_to_' + entityType.name;

    var _et = {
        name: paramEntityName,
        properties: {},
        navigates: {},
        keys: rows.map(function (row) {
            return row.VARIABLE_NAME;
        })
    };

    _et.navigates[resultsProp] = {
        name: resultsProp,
        association: assocName,
        from: {
            principal: true
        }
    };

    var paramEntityType = new EntityType(_et);

    var mrows = rows.map(function (row) {
        return {
            KIND: model.entityKind.inputParameters,
            TABLE_NAME: null,
            COLUMN_NAME: row.VARIABLE_NAME,
            POSITION: row.ORDER,
            DATA_TYPE_NAME: row.COLUMN_TYPE_D || 'VARCHAR',
            IS_NULLABLE: true,
            LENGTH: null,
            SCALE: null,
            SEMANTIC_TYPE: row.SEMANTIC_TYPE,
            MANDATORY: row.MANDATORY,
            DESCRIPTION: row.DESCRIPTION,
            SELECTION_TYPE: row.SELECTION_TYPE,
            MULTILINE: row.MULTILINE
        };
    });

    assocName = paramEntityName + '_to_' + entityType.name;
    var association = new Association({
        name: assocName,
        principal: {
            type: paramEntityName,
            multiplicity: '1'
        },
        dependent: {
            type: entityType.name,
            multiplicity: '*'
        },
        referentialConstraint: false,
        over: null,
        isInputParametersAssociation: true
    });


    paramEntityType.init(new model.Metadata(mrows), model.entityKind.inputParameters, null, context.logger);
    context.gModel.addEntity(paramEntityType);
    context.gModel.addAssociation(association);
    return paramEntityType;
}


function loadInputParametersViaKey(entityType, paramEntityType) {
    var pvalues = _.values(paramEntityType.propertiesMap);
    pvalues.forEach(function (pv) {
        entityType.addProperty(pv, true);
    });
}

function loadEntityType(context, entityType, cbErr) {
    determineStoreType(context, entityType, function (error, tableStoreType) {
        if (error) {
            return cbErr(error);
        }

        return loadTableInfo(context, entityType, tableStoreType, function (err, entityType1) {
            if (err) {
                return cbErr(err, entityType1);
            }

            return loadCalcViewInfo(context, entityType1, function (errCv, entityTypeCV) {
                if (errCv) {
                    return cbErr(errCv);
                }
                return cbErr(null, entityTypeCV);
            });
        });
    });
}

/**
 * Determines HANA store type ("column" or "row") for the table / view, which is used for the specified
 * <code>entityType</code>.
 *
 * @param {Object} context - OData context
 * @param {Object} entityType - entity type, for which table the store type should be determined
 * @param {Function} callback - callback function, which is called when the operation is completed.
 */
function determineStoreType(context, entityType, callback) {
    var schema = entityType.schema || context.defaultSchema,
        sql = 'select IS_COLUMN_TABLE as "IS_COLUMN_TYPE" from TABLES where SCHEMA_NAME = ? AND TABLE_NAME = ? ' +
            'union select IS_COLUMN_VIEW as "IS_COLUMN_TYPE" from VIEWS where SCHEMA_NAME = ? AND VIEW_NAME = ?',
        tableName = entityType.tableName,
        parameters = [schema, tableName, schema, tableName];

    context.logger.silly("model", "sql determineStoreType: " + sql);
    context.logger.silly("model", "sql determineStoreType parameters: " + parameters);

    context.db.client.prepare(sql, function (err, statement) {
        if (err) {
            return callback(new SqlError(context, err));
        }
        statement.exec(parameters, function (error, rows) {
            return processTableType(error, rows, context, tableName, callback);
        });
    });
}

/**
 * Callback, which is used to handle values, produced by determineStoreType function.
 *
 * @param {Object} error - error, produced by determineStoreType function
 * @param {Object[]} dbRows - database entries, produced by determineStoreType function
 * @param {Object} context - OData context
 * @param {string} tableName - DB table name, for which store type should be determined
 * @param {Function} callback - callback function, which is called when the operation is completed.
 */
function processTableType(error, dbRows, context, tableName, callback) {
    var isColumnStoreType,
        tableStoreType;

    if (error) {
        return callback(new SqlError(context, error));
    }

    if (dbRows.length === 0) {
        return callback(new NotFound("No data found for " + tableName + " table.", context));
    }

    context.logger.silly("processTableType", "rows:\n" + JSON.stringify(dbRows, null, 4));

    isColumnStoreType = dbRows[0].IS_COLUMN_TYPE;

    // HANA returns "TRUE"/"FALSE" as a string and not as a boolean value
    tableStoreType = isColumnStoreType === "TRUE" ? "column" : "row";
    return callback(null, tableStoreType);
}

exports._processTableType = processTableType;

function createLockeEntityID(context, entityType) {
    return (context.uriTree.xsoFile || '') + '_' + entityType.name;
}


function loadEntityTypeOnce(context, entityType, cbErr) {
    var lockEntityID = createLockeEntityID(context, entityType);

    if (entityType.isInitialised) {
        //access to __metadata is writelooked, so __metadata is definitively filled here
        return cbErr();
    }

    context.logger.silly('model', 'entitytype load: ' + lockEntityID);

    locks.writeLock(lockEntityID, function (release) {
        //if loaded in the meantime
        if (entityType.isInitialised) {
            release();
            return cbErr();
        }

        var load = function (err, context) {
            if (err) {
                release();
                return cbErr(err);
            }

            return loadEntityType(context, entityType, function (err) {
                release();
                return cbErr(err);
            });
        };
        try {
            if (Measurement.isActive()) {
                var callConnect = utils.tryAndMeasure(db.connect, 'dbConnect');
                return callConnect(context, load);
            } else {
                return db.connect(context, load);
            }
        } catch (err) {
            release();
            return cbErr(err);
        }
    });
}

exports.loadModelMetadata = function (context, asyncDone) {

    context.logger.silly('model', 'load metadata');

    var entityTypes = context.gModel.getEntityTypes();

    if (Measurement.isActive()) { // perform an explicit measurement
        var parent = Measurement.getRunningMeasurement();
    }

    async.mapSeries(
        entityTypes,
        function (entityType, cbMapLimit) {
            var child;
            try {
                if (Measurement.isActive() && !context.batchContext) {
                    child = parent.newChild(entityType.name);
                    child.counterStart();
                }

                return loadEntityTypeOnce(context, entityType, function (err) {
                    //stop measurement
                    if (Measurement.isActive() && !context.batchContext) {
                        child.counterStop();
                    }
                    return cbMapLimit(err);
                });

            } catch (ex) {
                //stop measurement
                if (Measurement.isActive() && !context.batchContext) {
                    child.counterStop();
                }
                return cbMapLimit(ex);
            }
        },
        function (err) {
            context.logger.silly('model', 'loadEntityTypes finished for ' + context.uriTree.xsoFile);
            return asyncDone(err, context);
        }
    );
};






