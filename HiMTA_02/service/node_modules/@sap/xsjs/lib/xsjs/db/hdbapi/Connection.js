'use strict';

var _ = require('lodash');
var assert = require('assert');
var hdbext = require('@sap/hdbext');
var ResultSetIterator = require('./ResultSetIterator.js');
var ctypes = require('../../../ctypes');
var convert = require('../common/convert');
var DB_TYPE = hdbext.constants.types;
var bufferUtils = require('../../../utils/buffer-utils');
var dateUtils = require('../../../utils/date-utils');
var decimalUtils = require('../../../utils/decimal-utils');
var moment = require('moment');


module.exports = Connection;

/**
 * @class $.hdb.Connection
 * @classdesc HANA database connection.
 * @constructor
 */
function Connection(client, treatDateAsUTC) {
  assert(typeof client === 'object', 'A valid client object should be provided to create $.hdb.Connection');
  this._client = client;
  this._treatDateAsUTC = treatDateAsUTC;
}

/**
 * Returns the hdb client (ref: https://github.com/SAP/node-hdb)
 */
Connection.prototype.getClient = function () {
  return this._client;
};

/**
 * Closes the connection
 * @throws Throws an error if the operation fails.
 */
Connection.prototype.close = function () {
  if (this._client) {
    this._client.close();
    this._client = null;
  }
};

/**
 * Commits the changes and ends the current transaction. <b>By default autocommit mode is disabled, which means all database changes must be explicitly commited.</b>
 * @throws Throws an error if the operation fails.
 * @example
 *
 * var connection = $.hdb.getConnection();
 * connection.executeUpdate('UPDATE "DB_EXAMPLE"."ICECREAM" SET QUANTITY=? WHERE FLAVOR=?', 9, 'CHOCOLATE');
 * connection.commit();
 */
Connection.prototype.commit = function () {
  this._client.sync.commit();
};

/**
 * Reverts the changes and ends the current transaction.
 * @throws Throws an error if the operation fails.
 * @example
 *
 * var connection = $.hdb.getConnection();
 * connection.executeUpdate('UPDATE "DB_EXAMPLE"."ICECREAM" SET QUANTITY=? WHERE FLAVOR=?', 9, 'CHOCOLATE');
 * connection.rollback();
 */
Connection.prototype.rollback = function () {
  this._client.sync.rollback();
};

/**
 * Changes the auto-commit flag of the connection.
 * @param {bool} autoCommit A bool value, which can be true or false
 */
Connection.prototype.setAutoCommit = function (autoCommit) {
  this._client.setAutoCommit(autoCommit);
};

/**
 * Executes a database query.
 * @param {string} query The query string to be executed.
 * @param {...varArgs} [arguments] Variable number of arguments to be bound to the query parameters.
 * @returns {$.hdb.ResultSet}
 * @throws Throws an error if the statement cannot be executed.
 * @example
 * var connection = $.hdb.getConnection();
 * connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."ICECREAM"');
 * connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."ICECREAM" WHERE FLAVOR = ?', 'CHOCOLATE');
 * connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."ICECREAM" WHERE FLAVOR = ? AND PRICE < ?', 'STRAWBERRY', 2.50);
 */
Connection.prototype.executeQuery = function () {
  var args = Array.prototype.slice.call(arguments);
  args = normalizeInput(args, this._treatDateAsUTC);
  var rs = execWithMetadata.sync.call(null, this._client, args.shift(), args);
  return processResultSet(rs, this._treatDateAsUTC);
};

/**
 * Executes a SQL statement, which changes the database state. SELECT and CALL statements are not allowed here.
 * @param {string} statement The statement to be executed.
 * @param {...varArgs} [arguments] Variable number of arguments to be bound to the query parameters.
 * @returns {number|array} Number of affected rows | Array of numbers in case of batch update.
 * @throws Throws an error if the statement cannot be executed.
 * @example
 *
 * var connection = $.hdb.getConnection();
 * connection.executeUpdate('INSERT INTO "DB_EXAMPLE"."ICECREAM" VALUES (?,?,?)','STRAWBERRY', 2.50, 64.18);
 * connection.executeUpdate('UPDATE "DB_EXAMPLE"."CASH" SET INCOME=?', 64.18);
 * connection.executeUpdate('DELETE FROM "DB_EXAMPLE"."ICECREAM" WHERE FLAVOR = ?', 'STRAWBERRY');
 *
 * //Batch Insert
 * var argsArray = [["MINT", 3.50, 34.5], ["VANILLA", 2.50, 23.6], ["CHERRY", 4.50, 67.9]];
 * connection.executeUpdate('INSERT INTO "DB_EXAMPLE"."ICECREAM" VALUES (?,?,?)', argsArray)
 * connection.commit();
 */
Connection.prototype.executeUpdate = function () {
  var args = Array.prototype.slice.call(arguments);
  args = normalizeInput(args, this._treatDateAsUTC);
  return execWithMetadata.sync.call(null, this._client, args.shift(), args);
};

/**
 * Returns a JavaScript function representing the stored procedure being loaded.
 * @param {string} [schema] The schema to which the procedure belongs.
 * @param {string} procedure The name of the procedure.
 * @returns {function}
 * @example
 *
 * var connection = $.hdb.getConnection();
 * // looks for the stored procedure in the current schema
 * var fnSell = connection.loadProcedure('icecream.shop::sell');
 * // the procedure has signature 'DB_EXAMPLE'.'icecream.shop::sell'(IN flavor VARCHAR, IN quantity INTEGER, IN payment DECIMAL, OUT change DECIMAL)
 * var fnSell = connection.loadProcedure('DB_EXAMPLE', 'icecream.shop::sell');
 * // call the procedure just like calling a javascript function
 * // sell three ice cream cups with chocolate flavor for 20 bucks each
 * var result = fnSell('CHOCOLATE', 3, 20.00);
 * // alternatively use named parameters
 * var result = fnSell({FLAVOR: 'CHOCOLATE', QUANTITY: 3, PAYMENT: 20.00});
 * // result is a $.hdb.ProcedureResult object
 *
 * @example
 * <b><font size="4">Table Parameter Support For Stored Procedures</font></b>
 *
 * // the procedure has signature 'DB_EXAMPLE'.'icecream.shop::lower_price_by'(IN ice_cream_prices prices_table_type, IN lower_price_by DOUBLE, OUT new_ice_cream_prices prices_table_type)
 * var fnlowerPrice = connection.loadProcedure('DB_EXAMPLE', 'icecream.shop::lower_price_by');
 *
 * // passing a $.hdb.ResultSet object
 * var price_list = connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."SOLD_FLAVORS_PRICES"');
 * var result = fnlowerPrice(price_list, 1.50);
 *
 * // passing a string containing the name of existing table in the database
 * var result = fnlowerPrice('"DB_EXAMPLE"."SOLD_FLAVORS_PRICES"', 1.50);
 *
 * // passing an array of JSON objects representing the rows in the table
 * var price_list = [{FLAVOR: 'STRAWBERRY', PRICE: 4.50}, {FLAVOR : 'VANILLA', PRICE: 3.50}, {FLAVOR: 'CHOCOLATE', PRICE: 5.50}];
 * var result = fnlowerPrice(price_list, 1.50);
 *
 * // We can get the table output parameter "new_ice_cream_prices" like any other output parameter:
 * var new_price_list = result.NEW_ICE_CREAM_PRICES;
 * // new_price_list is a $.hdb.ResultSet object
 */
Connection.prototype.loadProcedure = function (schema, name) {
  var treatDateAsUTC = this._treatDateAsUTC;
  if (arguments.length === 1) {
    name = arguments[0];
    schema = undefined;
  }

  var storedProc = hdbext.sync.loadProcedure(this._client, schema, name);

  return callsp.sync.bind(this);

  function callsp() {
    var inargs = Array.prototype.slice.call(arguments);
    var cb = inargs.pop();
    inargs = normalizeInput(inargs, treatDateAsUTC);
    inargs = convertInput(inargs, storedProc.paramsMetadata);

    var ondone = function () {
      var args = arguments;
      var at = 0;

      var err = args[at++];
      if (err) {
        return cb(err);
      }

      var parameters = args[at++] || {};

      storedProc.paramsMetadata.forEach(function (i) {
        if (i.DATA_TYPE_NAME === 'TABLE_TYPE' && i.PARAMETER_TYPE === 'OUT') {
          parameters[i.PARAMETER_NAME] = processResultSet(args[at++], treatDateAsUTC);
        }
        if (!isOutgoing(i) || parameters[i.PARAMETER_NAME] === null) {
          return;
        }

        if (i.DATA_TYPE_NAME === 'BIGINT') {
          parameters[i.PARAMETER_NAME] = new ctypes.Int64(parameters[i.PARAMETER_NAME]);
        }
        if (i.DATA_TYPE_NAME === 'DECIMAL' || i.DATA_TYPE_NAME === 'SMALLDECIMAL') {
          parameters[i.PARAMETER_NAME] = decimalUtils.normalizeDecimal(parameters[i.PARAMETER_NAME]);
        }
        if (i.DATA_TYPE_NAME === 'BLOB' || i.DATA_TYPE_NAME === 'BINARY' || i.DATA_TYPE_NAME === 'VARBINARY') {
          parameters[i.PARAMETER_NAME] = bufferUtils.toArrayBuffer(parameters[i.PARAMETER_NAME]);
        }
        if (i.DATA_TYPE_NAME === 'CLOB' || i.DATA_TYPE_NAME === 'NCLOB') {
          parameters[i.PARAMETER_NAME] = parameters[i.PARAMETER_NAME].toString(); // expecting a Buffer from hdb driver
        }
        if (i.DATA_TYPE_NAME === 'DATE') {
          parameters[i.PARAMETER_NAME] = dateUtils.dateToJsDate(parameters[i.PARAMETER_NAME], treatDateAsUTC);
        }
        if (i.DATA_TYPE_NAME === 'TIME') {
          parameters[i.PARAMETER_NAME] = dateUtils.timeToJsDate(parameters[i.PARAMETER_NAME], treatDateAsUTC);
        }
        if (i.DATA_TYPE_NAME === 'SECONDDATE' || i.DATA_TYPE_NAME === 'TIMESTAMP') {
          parameters[i.PARAMETER_NAME] = dateUtils.dateTimeToJsDate(parameters[i.PARAMETER_NAME], treatDateAsUTC);
        }
      });

      var spResultSets = [];
      while (at < args.length) {
        spResultSets.push(processResultSet(args[at++], treatDateAsUTC));
      }

      Object.defineProperty(parameters, '$resultSets', { enumerable: false, value: spResultSets });
      cb(null, parameters);
    };
    inargs.push(ondone);
    storedProc.apply(null, inargs);
  }
};

function convertInput(input, paramsMetadata) {
  if (!paramsMetadata) {
    return input;
  }

  // in case called like sp({ a:1, b:2 })
  if (input.length === 1 && _.isObject(input[0]) && !_.isArray(input[0])) {
    paramsMetadata.forEach(function(metadata) {
      var value = input[0][metadata.PARAMETER_NAME];
      if (value) {
        input[0][metadata.PARAMETER_NAME] = convert(value, metadata.DATA_TYPE_NAME);
      }
    });
  } else {
    var inParamsMetadata = paramsMetadata.filter(function (meta) {
      return meta.PARAMETER_TYPE !== 'OUT';
    });
    input.forEach(function (arg, index) {
      input[index] = convert(arg, inParamsMetadata[index].DATA_TYPE_NAME);
    });
  }

  return input;
}

function normalizeInput(input, treatDateAsUTC) {
  // process objects with special semantics
  if (input instanceof ctypes.Int64) {
    return input.valueOf();
  }

  if (_.isBuffer(input)) {
    return input;
  }

  if (_.isArrayBuffer(input)) {
    return bufferUtils.toBuffer(input);
  }

  if (_.isDate(input)) {
    // hdb driver works with up to 3 digits for the fractional seconds
    return (treatDateAsUTC ? moment(input).utc() : moment(input)).format('YYYY-MM-DD HH:mm:ss.SSS');
  }

  // traverse container objects (including arrays)
  if (_.isObjectLike(input)) {
    for (var key in input) {
      input[key] = normalizeInput(input[key], treatDateAsUTC);
    }
    return input;
  }

  return input;
}

function isOutgoing(procParam) {
  return procParam.PARAMETER_TYPE === 'INOUT' || procParam.PARAMETER_TYPE === 'OUT';
}

function processResultSet(rs, treatDateAsUTC) {
  Object.defineProperty(rs, 'getIterator', { enumerable: false, value: function () { return new ResultSetIterator(rs); } });

  var names = getNamesOfColumnsForProcessing(rs.metadata);
  var row;
  for (var bigIntColumn of names.bigIntColumns) {
    for (row of rs) {
      if (row[bigIntColumn] !== null) {
        row[bigIntColumn] = new ctypes.Int64(row[bigIntColumn]);
      }
    }
  }
  for (var decimalColumn of names.decimalColumns) {
    for (row of rs) {
      if (row[decimalColumn] !== null) {
        row[decimalColumn] = decimalUtils.normalizeDecimal(row[decimalColumn]);
      }
    }
  }
  for (var binaryColumn of names.binaryColumns) {
    for (row of rs) {
      if (row[binaryColumn] !== null) {
        row[binaryColumn] = bufferUtils.toArrayBuffer(row[binaryColumn]);
      }
    }
  }
  for (var characterLobColumn of names.characterLobColumns) {
    for (row of rs) {
      if (row[characterLobColumn] !== null) {
        row[characterLobColumn] = row[characterLobColumn].toString(); // expecting a Buffer from hdb driver
      }
    }
  }
  for (var dateColumn of names.dateColumns) {
    for (row of rs) {
      if (row[dateColumn] !== null) {
        row[dateColumn] = dateUtils.dateToJsDate(row[dateColumn], treatDateAsUTC);
      }
    }
  }
  for (var timeColumn of names.timeColumns) {
    for (row of rs) {
      if (row[timeColumn] !== null) {
        row[timeColumn] = dateUtils.timeToJsDate(row[timeColumn], treatDateAsUTC);
      }
    }
  }
  for (var timestampColumn of names.timestampColumns) {
    for (row of rs) {
      if (row[timestampColumn] !== null) {
        row[timestampColumn] = dateUtils.dateTimeToJsDate(row[timestampColumn], treatDateAsUTC);
      }
    }
  }

  attachColumnIndices(rs);
  normalizeResultSetMetadata(rs);
  return rs;
}

function getNamesOfColumnsForProcessing(metadata) {
  var names = {
    bigIntColumns: [],
    decimalColumns: [],
    binaryColumns: [],
    characterLobColumns: [],
    dateColumns: [],
    timeColumns: [],
    timestampColumns: []
  };

  for (var columnMeta of metadata) {
    switch (columnMeta.dataType) {
    case DB_TYPE.BIGINT:
      names.bigIntColumns.push(columnMeta.columnDisplayName);
      break;
    case DB_TYPE.DECIMAL:
      names.decimalColumns.push(columnMeta.columnDisplayName);
      break;
    case DB_TYPE.BLOB:
    case DB_TYPE.BINARY:
    case DB_TYPE.VARBINARY:
      names.binaryColumns.push(columnMeta.columnDisplayName);
      break;
    case DB_TYPE.CLOB:
    case DB_TYPE.NCLOB: // TEXT columns are also received as NCLOB columns
      names.characterLobColumns.push(columnMeta.columnDisplayName);
      break;
    case DB_TYPE.DATE:
      names.dateColumns.push(columnMeta.columnDisplayName);
      break;
    case DB_TYPE.TIME:
      names.timeColumns.push(columnMeta.columnDisplayName);
      break;
    case DB_TYPE.SECONDDATE:
    case DB_TYPE.TIMESTAMP:
      names.timestampColumns.push(columnMeta.columnDisplayName);
      break;
    default:
      break;
    }
  }

  return names;
}

function attachColumnIndices(rs) {
  const metadata = [].concat(rs.metadata); // preserve metadata in the format returned from hdb driver
  const columnIndexObject = createColumnIndexObject(metadata);

  rs.forEach((row, index, rs) => {
    rs[index] = Object.assign(Object.create(columnIndexObject), row);
  });

  updateColumnIndexObject(columnIndexObject, metadata);
}

function createColumnIndexObject(metadata) {
  const properties = {};

  for (let index in metadata) {
    properties[index] = {
      enumerable: false,
      configurable: true,
      set: function (value) {
        this[Symbol.for(index)] = value;
      }
    };
  }

  return Object.defineProperties({}, properties);
}

function updateColumnIndexObject(columnIndexObject, metadata) {
  const properties = {};

  for (let index in metadata) {
    properties[index] = {
      enumerable: false,
      configurable: false,
      set: function () {
        throw new Error(`"${index}" is read-only`);
      },
      get: function () {
        const columnName = metadata[index].columnDisplayName;
        const valueByIndex = this[Symbol.for(columnName)];
        return valueByIndex !== undefined ? valueByIndex : this[columnName];
      }
    };
  }

  return Object.defineProperties(columnIndexObject, properties);
}

function normalizeResultSetMetadata(rs) {
  var columnsMetadata = [];
  var columnsCount = rs.metadata.length;
  for (var i = 0; i < columnsCount; ++i) {
    var metadata = rs.metadata.shift();
    var columnMetadata = {
      label: metadata.columnDisplayName,
      name: metadata.columnName,
      type: metadata.dataType,
      precision: metadata.length,
      scale: metadata.fraction,
      tableName: metadata.tableName,
      isNullable: metadata.isOptional()
    };
    columnsMetadata.push(columnMetadata);
  }
  rs.metadata.columns = columnsMetadata;
}

function execWithMetadata(client, sql, sqlArgs, cb) {
  if (!_.isString(sql)) {
    return cb(new Error('Invalid sql passed to hdb'));
  }

  function fetchRowsWithMetadata(err, rs) {
    if (err && _.isNil(rs)) {
      return cb(err);
    }

    var isBatchOperation = sqlArgs && Array.isArray(sqlArgs[0]);
    if (isBatchOperation && _.isNumber(rs)) {
      rs = [rs];
    }
    if (isBatchOperation && err && rs) {
      if (_.isNumber(err.code)) {
        var code = -Math.abs(err.code);
        rs = rs.map(function (value) { return (value === -3) ? code : value; });
        return cb(null, rs);
      }
    }

    if (err || !rs || !rs.fetch) {
      return cb(err, rs);
    }
    rs.fetch(function (err, rows) {
      if (err) {
        return cb(err);
      }
      cb(null, rows);
    });
  }

  if (!sqlArgs || (Array.isArray(sqlArgs) && !sqlArgs.length)) {
    return client.execute(sql, fetchRowsWithMetadata);
  }

  client.prepare(sql, function (err, st) {
    if (err) {
      return cb(err);
    }
    if (sqlArgs.length === 1 && Array.isArray(sqlArgs[0])) {
      sqlArgs = sqlArgs[0];
    }

    var convertedSqlArgs = applyDefaultConversions(sqlArgs, st.parameterMetadata);

    return st.execute(convertedSqlArgs, fetchRowsWithMetadata);
  });
}

function applyDefaultConversions(sqlArgs, parameterMetadata) {
  return sqlArgs.map(function(current, i) {
    if (_.isArray(current)) {
      return current.map(function(arg, j) {
        if (j < parameterMetadata.length) {
          return convert(arg, parameterMetadata[j].dataType);
        }
      });
    }

    return convert(current, parameterMetadata[i].dataType);
  });
}
