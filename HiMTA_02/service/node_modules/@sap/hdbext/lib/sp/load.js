'use strict';

var async = require('async');
var VError = require('verror');
var debug = require('debug')('hdbext:sp');
var clientSession = require('../client-session');
var StoredProcedure = require('./StoredProcedure');
var execWithPrepare = require('./utils').execWithPrepare;

module.exports = load;

function load(client, schema, name, callback) {
  var procInfo = {
    schema: null,
    name: name,
    metadata: null
  };

  async.waterfall([
    function resolveSchema(cb) {
      if (schema) {
        return cb(null, schema);
      }
      clientSession.getSchema(client, cb);
    },

    function resolveProcedureInfo(schema, cb) {
      procInfo.schema = schema;

      fetchMetadata(client, procInfo, function (err, metadata) {
        if (err) {
          return cb(err);
        }
        procInfo.metadata = metadata;

        if (procInfo.metadata.length) {
          return cb(null, procInfo);
        }

        checkSynonyms(client, procInfo, function (err, result) {
          if (err) {
            return cb(err);
          }

          if (!result.isSynonym) {
            debug('Procedure "%s"."%s" does not have any parameters', procInfo.schema, procInfo.name);
            return cb(null, procInfo);
          }

          debug('"%s"."%s" is a synonym for "%s"."%s"', procInfo.schema, procInfo.name, result.schema, result.name);

          // use the data of the referenced procedure
          procInfo.schema = result.schema;
          procInfo.name = result.name;
          procInfo.metadata = null;

          fetchMetadata(client, procInfo, function (err, metadata) {
            if (err) {
              return cb(err);
            }
            procInfo.metadata = metadata;
            cb(null, procInfo);
          });
        });

      });
    },

    function buildSpFunction(procInfo, cb) {
      var sp = new StoredProcedure(client, procInfo.schema, procInfo.name, procInfo.metadata);
      var spFunction = StoredProcedure.prototype.exec.bind(sp);
      spFunction.paramsMetadata = procInfo.metadata;
      cb(null, spFunction);
    }
  ], callback);
}

function fetchMetadata(client, procInfo, cb) {
  var sqlProcedureMetadata = 'SELECT PARAMETER_NAME, DATA_TYPE_NAME, PARAMETER_TYPE, HAS_DEFAULT_VALUE, IS_INPLACE_TYPE, TABLE_TYPE_SCHEMA, TABLE_TYPE_NAME' +
    ' FROM SYS.PROCEDURE_PARAMETERS WHERE SCHEMA_NAME = ? AND PROCEDURE_NAME = ? ORDER BY POSITION';

  execWithPrepare(client, sqlProcedureMetadata, [procInfo.schema, procInfo.name], cb);
}

function checkSynonyms(client, procInfo, cb) {
  var sqlLookupSynonym = 'SELECT OBJECT_SCHEMA, OBJECT_NAME, IS_VALID FROM SYS.SYNONYMS WHERE SCHEMA_NAME = ? AND SYNONYM_NAME = ?';

  execWithPrepare(client, sqlLookupSynonym, [procInfo.schema, procInfo.name], function (err, rs) {
    if (err) {
      return cb(err);
    }
    var result = { isSynonym: !!rs.length };
    if (!result.isSynonym) {
      return cb(null, result);
    }

    if (rs[0].IS_VALID !== 'TRUE') {
      debug('Data for synonym "%s"."%s": %j', procInfo.schema, procInfo.name, rs[0]);
      return cb(new VError('Synonym "%s"."%s" is not valid', procInfo.schema, procInfo.name));
    }

    result.schema = rs[0].OBJECT_SCHEMA;
    result.name = rs[0].OBJECT_NAME;
    cb(null, result);
  });
}
