'use strict';

var async = require('async');
var VError = require('verror');
var format = require('util').format;
var debug = require('debug')('hdbext:sp');
var wrapParams = require('./wrap-params');
var isInput = require('./utils').isInput;
var isInputTable = require('./utils').isInputTable;
var hasDefaultValue = require('./utils').hasDefaultValue;
var execWithPrepare = require('./utils').execWithPrepare;
var TempTable = require('./TempTable');

module.exports = StoredProcedure;

function StoredProcedure(client, schema, name, metadata) {
  this._client = client;
  this._schema = schema;
  this._name = name;
  this._metadata = metadata;
  this._cachedStatement = null;
  this._hasInputTables = metadata.some(isInputTable);
  this._hasParamWithDefaultValue = metadata.some(hasDefaultValue);
}

StoredProcedure.prototype.exec = function () {
  var args = Array.prototype.slice.call(arguments);
  var callback = args.pop();
  var params = wrapParams(this._metadata, args);

  if (!this._hasInputTables) {
    this._execNoInputTables(params, callback);
  } else {
    this._execWithInputTables(params, callback);
  }
};

StoredProcedure.prototype._execNoInputTables = function (params, callback) {
  if (this._cachedStatement) {
    return this._cachedStatement.exec(params.getAll(), callback);
  }

  var paramPlaceholders = [];
  this._metadata.forEach(function (paramMeta) {
    if (isInput(paramMeta) && hasDefaultValue(paramMeta) && !params.has(paramMeta.PARAMETER_NAME)) {
      return;
    }

    paramPlaceholders.push(paramPlaceHolder(paramMeta));
  });

  var sqlCallStatement = this._buildCallStatement(paramPlaceholders.join(', '));
  debug(sqlCallStatement);

  var self = this;
  this._client.prepare(sqlCallStatement, function (err, statement) {
    if (err) {
      return callback(err);
    }

    if (!self._hasParamWithDefaultValue) {
      self._cachedStatement = statement;
    }

    statement.exec(params.getAll(), function () {
      callback.apply(null, arguments);

      if (!self._cachedStatement) {
        statement.drop(function (err) {
          if (err) {
            debug('Could not drop prepared statement (%s).', sqlCallStatement, err);
          }
        });
      }
    });
  });
};

StoredProcedure.prototype._execWithInputTables = function (params, callback) {
  if (params.empty()) {
    return callback(new Error('Stored procedure ' + this._name + ' expects input parameters'));
  }

  try {
    var setup = setupProcedureCall(this, params);
    var tempTables = setup.tempTables;

    var sqlCallStatement = this._buildCallStatement(setup.paramPlaceholders.join(', '));
    debug(sqlCallStatement);
  } catch (err) {
    return callback(err);
  }

  async.waterfall([
    createTempTables.bind(null, tempTables),
    execWithPrepare.bind(null, this._client, sqlCallStatement, setup.input)
  ], function () {
    callback.apply(null, arguments);
    dropTempTables(tempTables); // drop the temp tables in the background
  });
};

StoredProcedure.prototype._buildCallStatement = function (paramPlaceholders) {
  return format('CALL "%s"."%s"(%s)', this._schema, this._name, paramPlaceholders);
};

function setupProcedureCall(sp, params) {
  var paramPlaceholders = [];
  var tempTables = [];
  var input = {};

  sp._metadata.forEach(function (paramMeta) {
    if (!isInput(paramMeta)) {
      paramPlaceholders.push(paramPlaceHolder(paramMeta));
      return;
    }

    if (hasDefaultValue(paramMeta) && !params.has(paramMeta.PARAMETER_NAME)) {
      return;
    }

    var paramName = paramMeta.PARAMETER_NAME;
    var paramValue = params.get(paramName);
    if (!isInputTable(paramMeta)) {
      paramPlaceholders.push(paramPlaceHolder(paramMeta));
      input[paramName] = paramValue;
      return;
    }

    if (typeof paramValue === 'string') {
      paramPlaceholders.push(paramPlaceHolder(paramMeta, paramValue)); // table name provided
      return;
    }

    if (!Array.isArray(paramValue)) {
      throw new Error('Table parameter ' + paramName +
        ' is expected to be an array of objects or a string with a table name');
    }

    var tempTable = new TempTable(sp, paramMeta, paramValue);
    tempTables.push(tempTable);
    paramPlaceholders.push(paramPlaceHolder(paramMeta, '"' + tempTable.getName() + '"'));
  });

  return { paramPlaceholders: paramPlaceholders, tempTables: tempTables, input: input };
}

function createTempTables(tempTables, cb) {
  async.each(tempTables, function (tempTable, eachCb) {
    tempTable.create(function (err) {
      eachCb(err && new VError(err, 'Could not create temporary table: %s', tempTable.getName()));
    });
  }, cb);
}

function dropTempTables(tempTables) {
  tempTables.forEach(function (tempTable) {
    tempTable.drop();
  });
}

function paramPlaceHolder(paramMeta, value) {
  return paramMeta.PARAMETER_NAME + ' => ' + (value || '?');
}
