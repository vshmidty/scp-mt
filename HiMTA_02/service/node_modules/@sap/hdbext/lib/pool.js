'use strict';

var _ = require('lodash');
var async = require('async');
var crypto = require('crypto');
var util = require('util');
var constants = require('./constants');
var factory = require('./client-factory');
var clientSession = require('./client-session');
var debug = require('debug')('hdbext:pool');
var safeSql = require('./safe-sql');

var INSUFFICIENT_PRIVILEGE_ERROR_CODE = 258;

var poolModule = require('generic-pool');
var LRU = require('lru-cache'),
  cache = LRU({
    max: 10,
    dispose: function (key, pool) {
      _drainPool(pool);
    }
  });

exports.getPool = getPool;
exports.createPool = createPool;

function createPool(hanaService, options) {
  var pool = _createPool(hanaService, options);
  return _getPoolObject(pool, hanaService);
}

function getPool(hanaService, options) {
  var key = hanaService.host + ':' + hanaService.port + ':' + hanaService.assertion + ':' + hanaService.user + ':' + hanaService.password;
  key = crypto.createHash('sha1').update(key).digest('hex');
  var pool = cache.get(key);
  if (!pool) {
    pool = _createPool(hanaService, options);
    cache.set(key, pool);
  }
  return _getPoolObject(pool, hanaService);
}

function _getPoolObject(pool, hanaService) {
  return {
    pool: pool,
    acquire: _acquireConnection.bind(null, pool, hanaService),
    release: _releaseToPool.bind(null, pool),
    drain: _drainPool.bind(null, pool)
  };
}

function _releaseToPool(pool, safeClient) {
  function handleError(err) {
    // Currently the 'user' from the service binding does not have the privileges required to access the view with the list of temporary tables.
    // Connection will be terminated in order not to be reused. Logging on level debug in order not to flood the logs.
    // Corresponding privileges will be added to the user in the service binding.
    var insufficientPriv = err.code === INSUFFICIENT_PRIVILEGE_ERROR_CODE ? 'Insufficient privileges' : '';
    debug('Could not reset connection: ', insufficientPriv, err);
    pool.destroy(client);
  }

  var client = Object.getPrototypeOf(safeClient);
  if (client === null) {
    return;
  }
  if (!client._connection.isIdle()) {
    client._connection._queue.once('drain', _releaseToPool.bind(this, pool, safeClient));
    return;
  }

  safeClient._connection = undefined;
  safeClient.emit('release');
  safeClient.removeAllListeners();
  client.removeAllListeners();
  Object.setPrototypeOf(safeClient, null);

  async.series([
    function (cb) {
      client.rollback(cb);
    },
    function (cb) {
      clientSession.unsetSessionVariables(client, client._connectionUpdatedSettings.session, cb);
    },
    function (cb) {
      client._connectionUpdatedSettings.session = undefined;
      client._connectionInitialSettings = _getDeltaDBSettings({}, {}, _.merge({}, client._connectionDefaultSettings, client._connectionInitialSettings, client._connectionUpdatedSettings));
      client._connectionUpdatedSettings = undefined;
      clientSession.updateConnectionOptions(client, client._connectionInitialSettings, cb);
    }
  ], function (err) {
    if (err) {
      return handleError(err);
    }

    async.waterfall([
      client.exec.bind(client, 'SELECT SCHEMA_NAME, TABLE_NAME, TEMPORARY_TABLE_TYPE FROM M_TEMPORARY_TABLES WHERE CONNECTION_ID = CURRENT_CONNECTION'),
      function (rs, cb) {
        var statements = rs.map(function (row) {
          var operation = (row.TEMPORARY_TABLE_TYPE === 'GLOBAL') ? 'TRUNCATE' : 'DROP';
          var table = util.format('%s.%s', safeSql.identifier(row.SCHEMA_NAME), safeSql.identifier(row.TABLE_NAME));
          return util.format('%s TABLE %s', operation, table);
        });

        async.each(statements, function (statement, eachCb) {
          client.exec(statement, function (err) {
            debug(statement, err);
            eachCb(err);
          });
        }, cb);
      },
      function (cb) {
        client.commit(cb);
      }
    ], function (err) {
      if (err) {
        return handleError(err);
      }
      pool.release(client);
    });
  });
}

function _acquireConnection(pool, hanaService, options, callback) {
  if (arguments.length === 3) {
    callback = arguments[2];
    options = {};
  }
  var _options = _.merge({}, hanaService, options);
  pool.acquire(function (err, client) {
    if (err) {
      return callback(err);
    }

    var safeClient = Object.create(client);
    client.close = _releaseToPool.bind(null, pool, safeClient);
    client.disconnect = _releaseToPool.bind(null, pool, safeClient);
    client.on('close', pool.destroy.bind(null, client));

    client._connectionUpdatedSettings = _getDeltaDBSettings(client._connectionDefaultSettings, client._connectionInitialSettings
                                                                                            , _.pick(_options,['session', 'autoCommit', 'locale', 'isolationLevel', 'schema']));
    clientSession.updateConnectionOptions(client, client._connectionUpdatedSettings, function (err) {
      callback(err, safeClient);
    });
  });
}

function _drainPool(pool) {
  pool.drain(function () {
    pool.destroyAllNow();
  });
}

function _createPool(hanaService, options) {
  debug('Creating pool');
  var defaultOptions = {
    max: 100,
    min: 0,
    idleTimeoutMillis: 10000,
    log: false,
    refreshIdle: false
  };

  options = _.extend(defaultOptions, options);

  var pool = poolModule.Pool({
    name: 'hana',
    create: function (callback) {
      debug('Creating client in pool');
      factory.openBaseConnection(hanaService, function (err, client) {
        if (err) {
          return callback(err);
        }

        client._connectionDefaultSettings = {
          autoCommit: true,
          locale: client.connectOptions.clientLocale,
          isolationLevel: constants.isolation['READ_COMMITTED']
        };

        client._connectionInitialSettings = {
          autoCommit: _.isNil(options.autoCommit) ? client._connectionDefaultSettings.autoCommit : !!options.autoCommit,
          locale: hanaService.locale || client._connectionDefaultSettings.clientLocale,
          isolationLevel: hanaService.isolationLevel || client._connectionDefaultSettings.isolationLevel,
          schema: hanaService.schema
        };

        clientSession.getSchema(client, function (err, schema) {
          client._connectionDefaultSettings.schema = schema;
          var updatedSettings = _getDeltaDBSettings(client._connectionDefaultSettings, client._connectionDefaultSettings, client._connectionInitialSettings);
          clientSession.updateConnectionOptions(client, updatedSettings, function (err) {
            if (err) {
              client.close();
              client = null;
            }
            callback(err, client);
          });
        });
      });
    },
    destroy: function (client) {
      debug('Destroying client from pool');
      client._connection.close();
    },
    validate: function (client) {
      return client.readyState === 'connected';
    },
    max: options.max,
    min: options.min,
    idleTimeoutMillis: options.idleTimeoutMillis,
    log: options.log,
    refreshIdle: options.refreshIdle,
    reapIntervalMillis: options.reapIntervalMillis,
    returnToHead: options.returnToHead,
    priorityRange: options.priorityRange
  });
  return pool;
}


function _getDeltaDBSettings(def, init, curr) {
  def = def || {};
  init = init || {};
  curr = curr || {};
  var res = {};
  _.union(_.keys(curr), _.keys(init)).forEach(function (key) {
    if (curr[key] === undefined && init[key] !== def[key] && init[key] !== undefined) {
      res[key] = def[key];
    } else {
      if (curr[key] !== init[key] && (init[key] !== undefined || def[key] !== curr[key])) {
        res[key] = curr[key];
      }
    }
  });

  return res;
}
